name: Deploy to Staging AKS

on:
    push:
        branches:
            - staging
    workflow_dispatch:

env:
    NAMESPACE: splits-network

jobs:
    build-and-push:
        name: Build and Push Images
        runs-on: ubuntu-latest
        environment: staging
        strategy:
            matrix:
                service:
                    - name: api-gateway
                      path: services/api-gateway
                    - name: identity-service
                      path: services/identity-service
                    - name: ats-service
                      path: services/ats-service
                    - name: network-service
                      path: services/network-service
                    - name: billing-service
                      path: services/billing-service
                    - name: notification-service
                      path: services/notification-service
                    - name: automation-service
                      path: services/automation-service
                    - name: document-service
                      path: services/document-service
                    - name: ai-service
                      path: services/ai-service
                    - name: document-processing-service
                      path: services/document-processing-service
                    - name: analytics-service
                      path: services/analytics-service
                    - name: chat-gateway
                      path: services/chat-gateway
                    - name: analytics-gateway
                      path: services/analytics-gateway
                    - name: chat-service
                      path: services/chat-service
                    - name: search-service
                      path: services/search-service
                    - name: gpt-service
                      path: services/gpt-service
                    - name: content-service
                      path: services/content-service
                    - name: integration-service
                      path: services/integration-service
                    - name: health-monitor
                      path: services/health-monitor
                    - name: portal
                      path: apps/portal
                    - name: candidate
                      path: apps/candidate
                    - name: corporate
                      path: apps/corporate
                    - name: status
                      path: apps/status
        steps:
            - name: Checkout code
              uses: actions/checkout@v4

            - name: Setup Node.js
              uses: actions/setup-node@v4
              with:
                  node-version: "20"

            - name: Install pnpm
              uses: pnpm/action-setup@v4
              with:
                  version: 9.14.4

            - name: Install dependencies
              run: pnpm install --frozen-lockfile

            - name: Login to Azure
              uses: azure/login@v2
              with:
                  creds: ${{ secrets.AZURE_CREDENTIALS }}

            - name: Login to Staging ACR
              run: |
                  az acr login --name ${{ secrets.ACR_NAME }}

            - name: Build and push image
              run: |
                  VERSION=$(cat VERSION)
                  IMAGE_TAG=${{ secrets.ACR_LOGIN_SERVER }}/${{ matrix.service.name }}:${{ github.sha }}
                  VERSION_TAG=${{ secrets.ACR_LOGIN_SERVER }}/${{ matrix.service.name }}:v${VERSION}-staging

                  # Build with appropriate build args based on service
                  if [ "${{ matrix.service.name }}" = "portal" ]; then
                    docker build \
                      -f ${{ matrix.service.path }}/Dockerfile \
                      -t $IMAGE_TAG \
                      --target production \
                      --build-arg NEXT_PUBLIC_API_URL=https://api.staging.splits.network/api \
                      --build-arg NEXT_PUBLIC_CHAT_GATEWAY_URL=wss://api.staging.splits.network/ws/chat \
                      --build-arg NEXT_PUBLIC_ANALYTICS_GATEWAY_URL=wss://api.staging.splits.network/ws/analytics \
                      --build-arg NEXT_PUBLIC_CANDIDATE_APP_URL=https://staging.applicant.network \
                      --build-arg NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=${{ secrets.SPLITS_CLERK_PUBLISHABLE_KEY }} \
                      --build-arg NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=${{ secrets.STRIPE_PUBLISHABLE_KEY }} \
                      --build-arg SENTRY_AUTH_TOKEN=${{ secrets.SENTRY_AUTH_TOKEN }} \
                      .
                  elif [ "${{ matrix.service.name }}" = "candidate" ]; then
                    docker build \
                      -f ${{ matrix.service.path }}/Dockerfile \
                      -t $IMAGE_TAG \
                      --target production \
                      --build-arg NEXT_PUBLIC_API_URL=https://api.staging.splits.network/api \
                      --build-arg NEXT_PUBLIC_API_GATEWAY_URL=https://api.staging.splits.network \
                      --build-arg NEXT_PUBLIC_CHAT_GATEWAY_URL=wss://api.staging.splits.network/ws/chat \
                      --build-arg NEXT_PUBLIC_ANALYTICS_GATEWAY_URL=wss://api.staging.splits.network/ws/analytics \
                      --build-arg NEXT_PUBLIC_APP_URL=https://staging.applicant.network \
                      --build-arg NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=${{ secrets.APP_CLERK_PUBLISHABLE_KEY }} \
                      --build-arg SENTRY_AUTH_TOKEN=${{ secrets.SENTRY_AUTH_TOKEN }} \
                      .
                  elif [ "${{ matrix.service.name }}" = "corporate" ]; then
                    docker build \
                      -f ${{ matrix.service.path }}/Dockerfile \
                      -t $IMAGE_TAG \
                      --target production \
                      --build-arg NEXT_PUBLIC_APP_URL=https://staging.employment-networks.com \
                      .
                  elif [ "${{ matrix.service.name }}" = "status" ]; then
                    docker build \
                      -f ${{ matrix.service.path }}/Dockerfile \
                      -t $IMAGE_TAG \
                      --target production \
                      --build-arg NEXT_PUBLIC_APP_URL=https://staging.status.splits.network \
                      --build-arg NEXT_PUBLIC_API_GATEWAY_URL=https://api.staging.splits.network \
                      .
                  else
                    docker build \
                      -f ${{ matrix.service.path }}/Dockerfile \
                      -t $IMAGE_TAG \
                      --target production \
                      .
                  fi

                  # Push with commit SHA
                  docker push $IMAGE_TAG

                  # Tag and push with version-staging
                  docker tag $IMAGE_TAG $VERSION_TAG
                  docker push $VERSION_TAG

                  # Tag and push as staging-latest
                  docker tag $IMAGE_TAG ${{ secrets.ACR_LOGIN_SERVER }}/${{ matrix.service.name }}:staging-latest
                  docker push ${{ secrets.ACR_LOGIN_SERVER }}/${{ matrix.service.name }}:staging-latest

            - name: Create Sentry release (staging)
              if: matrix.service.name == 'portal' || matrix.service.name == 'candidate' || matrix.service.name == 'corporate' || matrix.service.name == 'api-gateway' || matrix.service.name == 'identity-service' || matrix.service.name == 'ats-service' || matrix.service.name == 'network-service' || matrix.service.name == 'billing-service' || matrix.service.name == 'notification-service' || matrix.service.name == 'ai-service' || matrix.service.name == 'analytics-service'
              continue-on-error: true
              env:
                  SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
                  SENTRY_ORG: splitsnetwork
              run: |
                  VERSION=$(cat VERSION)
                  RELEASE="${{ matrix.service.name }}@v${VERSION}-staging"
                  PROJECT_SLUG="${{ matrix.service.name }}"

                  # Install Sentry CLI
                  curl -sL https://sentry.io/get-cli/ | bash

                  # Create release
                  sentry-cli releases new $RELEASE --project $PROJECT_SLUG --finalize

                  # Associate commits
                  sentry-cli releases set-commits $RELEASE --project $PROJECT_SLUG --auto --ignore-missing

                  # Deploy to staging
                  sentry-cli releases deploys $RELEASE --project $PROJECT_SLUG new -e staging

    deploy:
        name: Deploy to Staging AKS
        runs-on: ubuntu-latest
        environment: staging
        needs: build-and-push
        steps:
            - name: Checkout code
              uses: actions/checkout@v4

            - name: Login to Azure
              uses: azure/login@v2
              with:
                  creds: ${{ secrets.AZURE_CREDENTIALS }}

            - name: Get Staging AKS credentials
              run: |
                  az aks get-credentials \
                    --resource-group ${{ secrets.AKS_RESOURCE_GROUP }} \
                    --name ${{ secrets.AKS_CLUSTER_NAME }} \
                    --overwrite-existing

            - name: Install nginx-ingress controller
              run: |
                  # Check if ingress-nginx is already installed
                  if ! kubectl get namespace ingress-nginx &>/dev/null; then
                    echo "Installing nginx-ingress controller..."
                    kubectl apply -f infra/k8s/ingress-nginx/deploy.yaml
                    
                    # Wait for ingress-nginx to be ready
                    echo "Waiting for ingress-nginx controller to be ready..."
                    kubectl wait --for=condition=Available deployment/ingress-nginx-controller -n ingress-nginx --timeout=180s
                  else
                    echo "nginx-ingress controller already installed, ensuring latest version..."
                    kubectl apply -f infra/k8s/ingress-nginx/deploy.yaml
                    kubectl wait --for=condition=Available deployment/ingress-nginx-controller -n ingress-nginx --timeout=180s
                  fi

            - name: Install cert-manager
              run: |
                  # Check if cert-manager is already installed
                  if ! kubectl get namespace cert-manager &>/dev/null; then
                    echo "Installing cert-manager..."
                    kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.14.4/cert-manager.yaml
                    
                    # Wait for cert-manager to be ready
                    echo "Waiting for cert-manager pods to be ready..."
                    kubectl wait --for=condition=Available deployment/cert-manager -n cert-manager --timeout=120s
                    kubectl wait --for=condition=Available deployment/cert-manager-webhook -n cert-manager --timeout=120s
                    kubectl wait --for=condition=Available deployment/cert-manager-cainjector -n cert-manager --timeout=120s
                  else
                    echo "cert-manager already installed"
                  fi

            - name: Apply cert-manager ClusterIssuer
              run: |
                  kubectl apply -f infra/k8s/cert-manager/cluster-issuer.yaml

            - name: Create namespace if not exists
              run: |
                  kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

            - name: Create secrets
              run: |
                  kubectl create secret generic supabase-secrets \
                    --from-literal=supabase-url="${{ secrets.SUPABASE_URL }}" \
                    --from-literal=supabase-anon-key="${{ secrets.SUPABASE_ANON_KEY }}" \
                    --from-literal=supabase-service-role-key="${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" \
                    --namespace=${{ env.NAMESPACE }} \
                    --dry-run=client -o yaml | kubectl apply -f -

                  # Clerk secrets for API Gateway (both portal and candidate app credentials)
                  kubectl create secret generic clerk-secrets \
                    --from-literal=splits-clerk-publishable-key="${{ secrets.SPLITS_CLERK_PUBLISHABLE_KEY }}" \
                    --from-literal=splits-clerk-secret-key="${{ secrets.SPLITS_CLERK_SECRET_KEY }}" \
                    --from-literal=splits-clerk-jwks-url="${{ secrets.SPLITS_CLERK_JWKS_URL }}" \
                    --from-literal=splits-clerk-webhook-secret="${{ secrets.SPLITS_CLERK_WEBHOOK_SECRET }}" \
                    --from-literal=app-clerk-publishable-key="${{ secrets.APP_CLERK_PUBLISHABLE_KEY }}" \
                    --from-literal=app-clerk-secret-key="${{ secrets.APP_CLERK_SECRET_KEY }}" \
                    --from-literal=app-clerk-jwks-url="${{ secrets.APP_CLERK_JWKS_URL }}" \
                    --from-literal=app-clerk-webhook-secret="${{ secrets.APP_CLERK_WEBHOOK_SECRET }}" \
                    --namespace=${{ env.NAMESPACE }} \
                    --dry-run=client -o yaml | kubectl apply -f -

                  kubectl create secret generic stripe-secrets \
                    --from-literal=stripe-secret-key="${{ secrets.STRIPE_SECRET_KEY }}" \
                    --from-literal=stripe-webhook-secret="${{ secrets.STRIPE_WEBHOOK_SECRET }}" \
                    --from-literal=stripe-publishable-key="${{ secrets.STRIPE_PUBLISHABLE_KEY }}" \
                    --namespace=${{ env.NAMESPACE }} \
                    --dry-run=client -o yaml | kubectl apply -f -

                  kubectl create secret generic resend-secrets \
                    --from-literal=resend-api-key="${{ secrets.RESEND_API_KEY }}" \
                    --namespace=${{ env.NAMESPACE }} \
                    --dry-run=client -o yaml | kubectl apply -f -

                  kubectl create secret generic openai-secrets \
                    --from-literal=openai-api-key="${{ secrets.OPENAI_API_KEY }}" \
                    --namespace=${{ env.NAMESPACE }} \
                    --dry-run=client -o yaml | kubectl apply -f -

                  kubectl create secret generic internal-service-secrets \
                    --from-literal=internal-service-key="${{ secrets.INTERNAL_SERVICE_KEY }}" \
                    --namespace=${{ env.NAMESPACE }} \
                    --dry-run=client -o yaml | kubectl apply -f -

                  kubectl create secret generic gpt-secrets \
                    --from-literal=gpt-client-id="${{ secrets.GPT_CLIENT_ID }}" \
                    --from-literal=gpt-client-secret="${{ secrets.GPT_CLIENT_SECRET }}" \
                    --from-literal=gpt-ec-private-key="${{ secrets.GPT_EC_PRIVATE_KEY }}" \
                    --from-literal=gpt-redirect-uri="${{ secrets.GPT_REDIRECT_URI }}" \
                    --from-literal=gpt-clerk-webhook-secret="${{ secrets.GPT_CLERK_WEBHOOK_SECRET }}" \
                    --namespace=${{ env.NAMESPACE }} \
                    --dry-run=client -o yaml | kubectl apply -f -

                  kubectl create secret generic integration-secrets \
                    --from-literal=google-client-id="${{ secrets.GOOGLE_CLIENT_ID }}" \
                    --from-literal=google-client-secret="${{ secrets.GOOGLE_CLIENT_SECRET }}" \
                    --from-literal=microsoft-client-id="${{ secrets.MICROSOFT_CLIENT_ID }}" \
                    --from-literal=microsoft-client-secret="${{ secrets.MICROSOFT_CLIENT_SECRET }}" \
                    --from-literal=linkedin-client-id="${{ secrets.LINKEDIN_CLIENT_ID }}" \
                    --from-literal=linkedin-client-secret="${{ secrets.LINKEDIN_CLIENT_SECRET }}" \
                    --namespace=${{ env.NAMESPACE }} \
                    --dry-run=client -o yaml | kubectl apply -f -

            - name: Update image tags in manifests
              run: |
                  export IMAGE_TAG=${{ github.sha }}
                  export ACR_SERVER=${{ secrets.ACR_LOGIN_SERVER }}
                  export API_BASE_URL="https://api.staging.splits.network"
                  export CHAT_GATEWAY_URL="wss://api.staging.splits.network/ws/chat"
                  export ANALYTICS_GATEWAY_URL="wss://api.staging.splits.network/ws/analytics"
                  export PORTAL_URL="https://staging.splits.network"
                  export CANDIDATE_URL="https://staging.applicant.network"
                  export CORPORATE_URL="https://staging.employment-networks.com"
                  export STATUS_URL="https://staging.status.splits.network"

                  # Use envsubst to replace image tags in all deployment files
                  for file in infra/k8s/*/deployment.yaml; do
                    envsubst < "$file" > "${file}.tmp"
                    mv "${file}.tmp" "$file"
                  done

                  # ðŸ”§ FIX: Also process cronjobs and jobs files
                  for file in infra/k8s/*/cronjobs/*.yaml; do
                    if [ -f "$file" ]; then
                      envsubst < "$file" > "${file}.tmp"
                      mv "${file}.tmp" "$file"
                    fi
                  done

                  for file in infra/k8s/*/jobs/*.yaml; do
                    if [ -f "$file" ]; then
                      envsubst < "$file" > "${file}.tmp"
                      mv "${file}.tmp" "$file"
                    fi
                  done

            - name: Deploy infrastructure (Redis, RabbitMQ)
              run: |
                  kubectl apply -f infra/k8s/redis/ --namespace=${{ env.NAMESPACE }}
                  kubectl apply -f infra/k8s/rabbitmq/ --namespace=${{ env.NAMESPACE }}

            - name: Wait for infrastructure to be ready
              run: |
                  kubectl rollout status deployment/redis --timeout=120s --namespace=${{ env.NAMESPACE }}
                  kubectl rollout status deployment/rabbitmq --timeout=120s --namespace=${{ env.NAMESPACE }}

            - name: Deploy backend services
              run: |
                  SERVICES="identity-service ats-service network-service billing-service notification-service automation-service document-service document-processing-service ai-service analytics-service chat-gateway analytics-gateway chat-service gpt-service content-service integration-service health-monitor"
                  for svc in $SERVICES; do
                    if [ -f "infra/k8s/$svc/deployment.yaml" ]; then
                      kubectl apply -f "infra/k8s/$svc/" --namespace=${{ env.NAMESPACE }}
                      if [ "$svc" = "ats-service" ]; then
                        kubectl apply -f "infra/k8s/$svc/cronjobs/" --namespace=${{ env.NAMESPACE }}
                      fi
                      if [ "$svc" = "billing-service" ]; then
                        kubectl apply -f "infra/k8s/$svc/cronjobs/" --namespace=${{ env.NAMESPACE }}
                      fi
                    fi
                  done

            - name: Wait for services to be ready
              run: |
                  kubectl rollout status deployment/identity-service --timeout=180s --namespace=${{ env.NAMESPACE }}
                  kubectl rollout status deployment/ats-service --timeout=180s --namespace=${{ env.NAMESPACE }}
                  kubectl rollout status deployment/network-service --timeout=180s --namespace=${{ env.NAMESPACE }}
                  kubectl rollout status deployment/billing-service --timeout=180s --namespace=${{ env.NAMESPACE }}
                  kubectl rollout status deployment/notification-service --timeout=180s --namespace=${{ env.NAMESPACE }}
                  kubectl rollout status deployment/automation-service --timeout=180s --namespace=${{ env.NAMESPACE }}
                  kubectl rollout status deployment/document-service --timeout=180s --namespace=${{ env.NAMESPACE }}
                  kubectl rollout status deployment/ai-service --timeout=180s --namespace=${{ env.NAMESPACE }}
                  kubectl rollout status deployment/document-processing-service --timeout=180s --namespace=${{ env.NAMESPACE }}
                  kubectl rollout status deployment/analytics-service --timeout=180s --namespace=${{ env.NAMESPACE }}
                  kubectl rollout status deployment/chat-gateway --timeout=180s --namespace=${{ env.NAMESPACE }}
                  kubectl rollout status deployment/analytics-gateway --timeout=180s --namespace=${{ env.NAMESPACE }}
                  kubectl rollout status deployment/chat-service --timeout=180s --namespace=${{ env.NAMESPACE }}
                  kubectl rollout status deployment/health-monitor --timeout=180s --namespace=${{ env.NAMESPACE }}
                  kubectl rollout status deployment/gpt-service --timeout=180s --namespace=${{ env.NAMESPACE }}
                  kubectl rollout status deployment/content-service --timeout=180s --namespace=${{ env.NAMESPACE }}
                  kubectl rollout status deployment/integration-service --timeout=180s --namespace=${{ env.NAMESPACE }}

            - name: Deploy API Gateway
              run: |
                  kubectl apply -f infra/k8s/api-gateway/ --namespace=${{ env.NAMESPACE }}

            - name: Wait for API Gateway to be ready
              run: |
                  kubectl rollout status deployment/api-gateway --timeout=180s --namespace=${{ env.NAMESPACE }}

            - name: Deploy frontend apps
              run: |
                  FRONTENDS="portal candidate corporate status"
                  for app in $FRONTENDS; do
                    if [ -f "infra/k8s/$app/deployment.yaml" ]; then
                      kubectl apply -f "infra/k8s/$app/" --namespace=${{ env.NAMESPACE }}
                    fi
                  done

            - name: Wait for frontends to be ready
              run: |
                  kubectl rollout status deployment/portal --timeout=180s --namespace=${{ env.NAMESPACE }}
                  kubectl rollout status deployment/candidate --timeout=180s --namespace=${{ env.NAMESPACE }}
                  kubectl rollout status deployment/corporate --timeout=180s --namespace=${{ env.NAMESPACE }}
                  kubectl rollout status deployment/status --timeout=180s --namespace=${{ env.NAMESPACE }}

            - name: Deploy staging ingress
              run: |
                  kubectl apply -f infra/k8s/staging-ingress.yaml --namespace=${{ env.NAMESPACE }}
                  kubectl delete job ats-backfill-guarantee-expires --ignore-not-found --namespace=${{ env.NAMESPACE }}
                  kubectl apply -f infra/k8s/ats-service/jobs/backfill-guarantee-expires.yaml --namespace=${{ env.NAMESPACE }}

            - name: Get deployment status
              run: |
                  echo "=== Staging Deployment Status ==="
                  kubectl get all --namespace=${{ env.NAMESPACE }}
                  echo ""
                  echo "=== Ingress Status ==="
                  kubectl get ingress --namespace=${{ env.NAMESPACE }}
                  echo ""
                  echo "=== Services ==="
                  kubectl get svc --namespace=${{ env.NAMESPACE }}
