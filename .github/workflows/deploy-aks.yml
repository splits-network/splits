name: Deploy to AKS

on:
    push:
        branches:
            - main
    workflow_dispatch:

jobs:
    build-and-push:
        name: Build and Push Images
        runs-on: ubuntu-latest
        environment: production
        strategy:
            matrix:
                service:
                    - name: api-gateway
                      path: services/api-gateway
                    - name: identity-service
                      path: services/identity-service
                    - name: ats-service
                      path: services/ats-service
                    - name: network-service
                      path: services/network-service
                    - name: billing-service
                      path: services/billing-service
                    - name: notification-service
                      path: services/notification-service
                    - name: automation-service
                      path: services/automation-service
                    - name: document-service
                      path: services/document-service
                    - name: ai-service
                      path: services/ai-service
                    - name: document-processing-service
                      path: services/document-processing-service
                    - name: analytics-service
                      path: services/analytics-service
                    - name: portal
                      path: apps/portal
                    - name: candidate
                      path: apps/candidate
                    - name: corporate
                      path: apps/corporate
        steps:
            - name: Checkout code
              uses: actions/checkout@v4

            - name: Setup Node.js (for Sentry source maps)
              uses: actions/setup-node@v4
              with:
                  node-version: "20"

            - name: Install pnpm
              uses: pnpm/action-setup@v4
              with:
                  version: 9.14.4

            - name: Install dependencies
              run: pnpm install --frozen-lockfile

            - name: Login to Azure
              uses: azure/login@v2
              with:
                  creds: ${{ secrets.AZURE_CREDENTIALS }}

            - name: Login to ACR
              run: |
                  az acr login --name ${{ secrets.ACR_NAME }}

            - name: Build and push image
              run: |
                  VERSION=$(cat VERSION)
                  IMAGE_TAG=${{ secrets.ACR_LOGIN_SERVER }}/${{ matrix.service.name }}:${{ github.sha }}
                  VERSION_TAG=${{ secrets.ACR_LOGIN_SERVER }}/${{ matrix.service.name }}:v${VERSION}

                  # Build with appropriate build args based on service
                  if [ "${{ matrix.service.name }}" = "portal" ]; then
                    docker build \
                      -f ${{ matrix.service.path }}/Dockerfile \
                      -t $IMAGE_TAG \
                      --target production \
                      --build-arg NEXT_PUBLIC_API_URL=https://api.splits.network/api \
                      --build-arg NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=${{ secrets.SPLITS_CLERK_PUBLISHABLE_KEY }} \
                      --build-arg NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=${{ secrets.STRIPE_PUBLISHABLE_KEY }} \
                      --build-arg SENTRY_AUTH_TOKEN=${{ secrets.SENTRY_AUTH_TOKEN }} \
                      .
                  elif [ "${{ matrix.service.name }}" = "candidate" ]; then
                    docker build \
                      -f ${{ matrix.service.path }}/Dockerfile \
                      -t $IMAGE_TAG \
                      --target production \
                      --build-arg NEXT_PUBLIC_API_URL=https://api.splits.network/api \
                      --build-arg NEXT_PUBLIC_API_GATEWAY_URL=https://api.splits.network \
                      --build-arg NEXT_PUBLIC_APP_URL=https://applicant.network \
                      --build-arg NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=${{ secrets.APP_CLERK_PUBLISHABLE_KEY }} \
                      --build-arg SENTRY_AUTH_TOKEN=${{ secrets.SENTRY_AUTH_TOKEN }} \
                      .
                  elif [ "${{ matrix.service.name }}" = "corporate" ]; then
                    docker build \
                      -f ${{ matrix.service.path }}/Dockerfile \
                      -t $IMAGE_TAG \
                      --target production \
                      --build-arg NEXT_PUBLIC_APP_URL=https://employment-networks.com \
                      .
                  else
                    docker build \
                      -f ${{ matrix.service.path }}/Dockerfile \
                      -t $IMAGE_TAG \
                      --target production \
                      .
                  fi

                  # Push with commit SHA
                  docker push $IMAGE_TAG

                  # Tag and push with version
                  docker tag $IMAGE_TAG $VERSION_TAG
                  docker push $VERSION_TAG

                  # Tag and push as latest
                  docker tag $IMAGE_TAG ${{ secrets.ACR_LOGIN_SERVER }}/${{ matrix.service.name }}:latest
                  docker push ${{ secrets.ACR_LOGIN_SERVER }}/${{ matrix.service.name }}:latest

            - name: Create Sentry release
              if: matrix.service.name == 'portal' || matrix.service.name == 'candidate' || matrix.service.name == 'corporate' || matrix.service.name == 'api-gateway' || matrix.service.name == 'identity-service' || matrix.service.name == 'ats-service' || matrix.service.name == 'network-service' || matrix.service.name == 'billing-service' || matrix.service.name == 'notification-service' || matrix.service.name == 'ai-service' || matrix.service.name == 'analytics-service'
              continue-on-error: true
              env:
                  SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
                  SENTRY_ORG: splitsnetwork
              run: |
                  VERSION=$(cat VERSION)
                  RELEASE="${{ matrix.service.name }}@v${VERSION}"
                  PROJECT_SLUG="${{ matrix.service.name }}"

                  # Install Sentry CLI
                  curl -sL https://sentry.io/get-cli/ | bash

                  # Create release
                  sentry-cli releases new $RELEASE --project $PROJECT_SLUG --finalize

                  # Associate commits (--ignore-missing handles first releases or shallow clones)
                  sentry-cli releases set-commits $RELEASE --project $PROJECT_SLUG --auto --ignore-missing

                  # Deploy to production
                  sentry-cli releases deploys $RELEASE --project $PROJECT_SLUG new -e production

    deploy:
        name: Deploy to AKS
        runs-on: ubuntu-latest
        environment: production
        needs: build-and-push
        steps:
            - name: Checkout code
              uses: actions/checkout@v4

            - name: Login to Azure
              uses: azure/login@v2
              with:
                  creds: ${{ secrets.AZURE_CREDENTIALS }}

            - name: Get AKS credentials
              run: |
                  az aks get-credentials \
                    --resource-group ${{ secrets.AKS_RESOURCE_GROUP }} \
                    --name ${{ secrets.AKS_CLUSTER_NAME }} \
                    --overwrite-existing

            - name: Install nginx-ingress controller
              run: |
                  # Check if ingress-nginx is already installed
                  if ! kubectl get namespace ingress-nginx &>/dev/null; then
                    echo "Installing nginx-ingress controller..."
                    kubectl apply -f infra/k8s/ingress-nginx/deploy.yaml
                    
                    # Wait for ingress-nginx to be ready
                    echo "Waiting for ingress-nginx controller to be ready..."
                    kubectl wait --for=condition=Available deployment/ingress-nginx-controller -n ingress-nginx --timeout=180s
                  else
                    echo "nginx-ingress controller already installed, ensuring latest version..."
                    kubectl apply -f infra/k8s/ingress-nginx/deploy.yaml
                    kubectl wait --for=condition=Available deployment/ingress-nginx-controller -n ingress-nginx --timeout=180s
                  fi

            - name: Install cert-manager
              run: |
                  # Check if cert-manager is already installed
                  if ! kubectl get namespace cert-manager &>/dev/null; then
                    echo "Installing cert-manager..."
                    kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.14.4/cert-manager.yaml
                    
                    # Wait for cert-manager to be ready
                    echo "Waiting for cert-manager pods to be ready..."
                    kubectl wait --for=condition=Available deployment/cert-manager -n cert-manager --timeout=120s
                    kubectl wait --for=condition=Available deployment/cert-manager-webhook -n cert-manager --timeout=120s
                    kubectl wait --for=condition=Available deployment/cert-manager-cainjector -n cert-manager --timeout=120s
                  else
                    echo "cert-manager already installed"
                  fi

            - name: Apply cert-manager ClusterIssuer
              run: |
                  kubectl apply -f infra/k8s/cert-manager/cluster-issuer.yaml

            - name: Create namespace if not exists
              run: |
                  kubectl create namespace splits-network --dry-run=client -o yaml | kubectl apply -f -

            - name: Create secrets
              run: |
                  kubectl create secret generic supabase-secrets \
                    --from-literal=supabase-url=${{ secrets.SUPABASE_URL }} \
                    --from-literal=supabase-anon-key=${{ secrets.SUPABASE_ANON_KEY }} \
                    --from-literal=supabase-service-role-key=${{ secrets.SUPABASE_SERVICE_ROLE_KEY }} \
                    --namespace=splits-network \
                    --dry-run=client -o yaml | kubectl apply -f -

                  # Clerk secrets for API Gateway (both portal and candidate app credentials)
                  kubectl create secret generic clerk-secrets \
                    --from-literal=splits-clerk-publishable-key=${{ secrets.SPLITS_CLERK_PUBLISHABLE_KEY }} \
                    --from-literal=splits-clerk-secret-key=${{ secrets.SPLITS_CLERK_SECRET_KEY }} \
                    --from-literal=splits-clerk-jwks-url=${{ secrets.SPLITS_CLERK_JWKS_URL }} \
                    --from-literal=app-clerk-publishable-key=${{ secrets.APP_CLERK_PUBLISHABLE_KEY }} \
                    --from-literal=app-clerk-secret-key=${{ secrets.APP_CLERK_SECRET_KEY }} \
                    --from-literal=app-clerk-jwks-url=${{ secrets.APP_CLERK_JWKS_URL }} \
                    --namespace=splits-network \
                    --dry-run=client -o yaml | kubectl apply -f -

                  kubectl create secret generic stripe-secrets \
                    --from-literal=stripe-secret-key=${{ secrets.STRIPE_SECRET_KEY }} \
                    --from-literal=stripe-webhook-secret=${{ secrets.STRIPE_WEBHOOK_SECRET }} \
                    --from-literal=stripe-publishable-key=${{ secrets.STRIPE_PUBLISHABLE_KEY }} \
                    --namespace=splits-network \
                    --dry-run=client -o yaml | kubectl apply -f -

                  kubectl create secret generic resend-secrets \
                    --from-literal=resend-api-key=${{ secrets.RESEND_API_KEY }} \
                    --namespace=splits-network \
                    --dry-run=client -o yaml | kubectl apply -f -

                  kubectl create secret generic openai-secrets \
                    --from-literal=openai-api-key=${{ secrets.OPENAI_API_KEY }} \
                    --namespace=splits-network \
                    --dry-run=client -o yaml | kubectl apply -f -

                  kubectl create secret generic internal-service-secrets \
                    --from-literal=internal-service-key=${{ secrets.INTERNAL_SERVICE_KEY }} \
                    --namespace=splits-network \
                    --dry-run=client -o yaml | kubectl apply -f -

            - name: Update image tags in manifests
              run: |
                  export IMAGE_TAG=${{ github.sha }}
                  export ACR_SERVER=${{ secrets.ACR_LOGIN_SERVER }}

                  # Use envsubst to replace image tags in all deployment files
                  for file in infra/k8s/*/deployment.yaml; do
                    envsubst < "$file" > "${file}.tmp"
                    mv "${file}.tmp" "$file"
                  done

            - name: Deploy infrastructure (Redis, RabbitMQ)
              run: |
                  kubectl apply -f infra/k8s/redis/ --namespace=splits-network
                  kubectl apply -f infra/k8s/rabbitmq/ --namespace=splits-network

            - name: Wait for infrastructure to be ready
              run: |
                  kubectl rollout status deployment/redis --timeout=120s --namespace=splits-network
                  kubectl rollout status deployment/rabbitmq --timeout=120s --namespace=splits-network

            - name: Deploy services
              run: |
                  kubectl apply -f infra/k8s/identity-service/ --namespace=splits-network
                  kubectl apply -f infra/k8s/ats-service/ --namespace=splits-network
                  kubectl apply -f infra/k8s/network-service/ --namespace=splits-network
                  kubectl apply -f infra/k8s/billing-service/ --namespace=splits-network
                  kubectl apply -f infra/k8s/notification-service/ --namespace=splits-network
                  kubectl apply -f infra/k8s/automation-service/ --namespace=splits-network
                  kubectl apply -f infra/k8s/document-service/ --namespace=splits-network
                  kubectl apply -f infra/k8s/ai-service/ --namespace=splits-network
                  kubectl apply -f infra/k8s/document-processing-service/ --namespace=splits-network
                  kubectl apply -f infra/k8s/analytics-service/ --namespace=splits-network

            - name: Wait for services to be ready
              run: |
                  kubectl rollout status deployment/identity-service --timeout=180s --namespace=splits-network
                  kubectl rollout status deployment/ats-service --timeout=180s --namespace=splits-network
                  kubectl rollout status deployment/network-service --timeout=180s --namespace=splits-network
                  kubectl rollout status deployment/billing-service --timeout=180s --namespace=splits-network
                  kubectl rollout status deployment/notification-service --timeout=180s --namespace=splits-network
                  kubectl rollout status deployment/automation-service --timeout=180s --namespace=splits-network
                  kubectl rollout status deployment/document-service --timeout=180s --namespace=splits-network
                  kubectl rollout status deployment/ai-service --timeout=180s --namespace=splits-network
                  kubectl rollout status deployment/document-processing-service --timeout=180s --namespace=splits-network
                  kubectl rollout status deployment/analytics-service --timeout=180s --namespace=splits-network

            - name: Deploy API Gateway
              run: |
                  kubectl apply -f infra/k8s/api-gateway/ --namespace=splits-network

            - name: Wait for API Gateway to be ready
              run: |
                  kubectl rollout status deployment/api-gateway --timeout=180s --namespace=splits-network

            - name: Deploy Portal
              run: |
                  kubectl apply -f infra/k8s/portal/ --namespace=splits-network

            - name: Wait for Portal to be ready
              run: |
                  kubectl rollout status deployment/portal --timeout=180s --namespace=splits-network

            - name: Deploy Candidate Website
              run: |
                  kubectl apply -f infra/k8s/candidate/ --namespace=splits-network

            - name: Wait for Candidate Website to be ready
              run: |
                  kubectl rollout status deployment/candidate --timeout=180s --namespace=splits-network

            - name: Deploy Corporate Website
              run: |
                  kubectl apply -f infra/k8s/corporate/ --namespace=splits-network

            - name: Wait for Corporate Website to be ready
              run: |
                  kubectl rollout status deployment/corporate --timeout=180s --namespace=splits-network

            - name: Deploy Ingress
              run: |
                  kubectl apply -f infra/k8s/ingress.yaml --namespace=splits-network

            - name: Get deployment status
              run: |
                  kubectl get all --namespace=splits-network
