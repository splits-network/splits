---
phase: 02-search-api
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - services/api-gateway/src/index.ts
  - services/api-gateway/src/routes/v2/search.ts
  - services/api-gateway/src/routes/v2/routes.ts
  - services/api-gateway/src/routes/v2/common.ts
autonomous: true

must_haves:
  truths:
    - "Frontend can call GET /api/v2/search?q=query&mode=typeahead through the API gateway and receive grouped results"
    - "Frontend can call GET /api/v2/search?q=query&mode=full through the API gateway and receive paginated results"
    - "API gateway requires authentication for search endpoints"
    - "API gateway forwards x-clerk-user-id header to search-service"
    - "search-service is registered in the service registry at port 3012"
  artifacts:
    - path: "services/api-gateway/src/routes/v2/search.ts"
      provides: "Search route proxy to search-service"
      contains: "registerSearchRoutes"
    - path: "services/api-gateway/src/routes/v2/routes.ts"
      provides: "Updated V2 route registration including search"
      contains: "registerSearchRoutes"
    - path: "services/api-gateway/src/index.ts"
      provides: "search-service registered in ServiceRegistry"
      contains: "services.register('search'"
  key_links:
    - from: "services/api-gateway/src/routes/v2/routes.ts"
      to: "services/api-gateway/src/routes/v2/search.ts"
      via: "import and call registerSearchRoutes"
      pattern: "registerSearchRoutes"
    - from: "services/api-gateway/src/routes/v2/search.ts"
      to: "services/api-gateway/src/clients.ts"
      via: "services.get('search')"
      pattern: "services\\.get\\('search'\\)"
    - from: "services/api-gateway/src/index.ts"
      to: "search-service"
      via: "services.register('search', ...)"
      pattern: "services\\.register\\('search'"
---

<objective>
Register the search-service in the API gateway and create proxy routes so the portal frontend can call GET /api/v2/search through the gateway.

Purpose: Wire the search-service created in Plan 01 to the gateway's front door so it's accessible from the frontend via the standard API call pattern.

Output: API gateway proxies search requests to search-service, with authentication required.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-search-api/02-01-SUMMARY.md

Key reference files:
@services/api-gateway/src/index.ts (service registration pattern)
@services/api-gateway/src/routes/v2/routes.ts (V2 route registration)
@services/api-gateway/src/routes/v2/analytics.ts (proxy route pattern)
@services/api-gateway/src/routes/v2/common.ts (shared helpers: getCorrelationId, buildQueryString, ServiceName, registerResourceRoutes)
@services/api-gateway/src/helpers/auth-headers.ts (buildAuthHeaders helper)
@services/api-gateway/src/middleware/auth.ts (requireAuth middleware)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Register search-service in API gateway and create proxy routes</name>
  <files>
    services/api-gateway/src/index.ts
    services/api-gateway/src/routes/v2/search.ts
    services/api-gateway/src/routes/v2/routes.ts
    services/api-gateway/src/routes/v2/common.ts
  </files>
  <action>
    **1. Update `services/api-gateway/src/routes/v2/common.ts`:**
    Add `'search'` to the `ServiceName` type union. This is a single-line change:
    ```typescript
    export type ServiceName =
        | 'analytics'
        | 'ats'
        | 'network'
        | 'billing'
        | 'notification'
        | 'identity'
        | 'document'
        | 'automation'
        | 'search';  // ADD THIS
    ```

    **2. Update `services/api-gateway/src/index.ts`:**
    Add search-service to the service registry. Add this line after the `chat` service registration:
    ```typescript
    services.register('search', process.env.SEARCH_SERVICE_URL || 'http://localhost:3012');
    ```

    **3. Create `services/api-gateway/src/routes/v2/search.ts`:**
    Follow the pattern from `analytics.ts` for custom proxy routes (NOT the generic registerResourceRoutes pattern, since search has a non-standard single GET endpoint).

    ```typescript
    import { FastifyInstance, FastifyReply, FastifyRequest } from 'fastify';
    import { ServiceRegistry } from '../../clients';
    import { getCorrelationId, buildQueryString } from './common';
    import { buildAuthHeaders } from '../../helpers/auth-headers';
    import { requireAuth } from '../../middleware/auth';

    export function registerSearchRoutes(
        app: FastifyInstance,
        services: ServiceRegistry
    ): void {
        const searchClient = () => services.get('search');

        // GET /api/v2/search - Global search (typeahead and full modes)
        app.get(
            '/api/v2/search',
            { preHandler: requireAuth() },
            async (request: FastifyRequest, reply: FastifyReply) => {
                const correlationId = getCorrelationId(request);
                const queryString = buildQueryString(request.query as Record<string, any>);
                const path = queryString ? `/api/v2/search?${queryString}` : '/api/v2/search';

                try {
                    const response = await searchClient().get<any>(
                        path,
                        undefined,
                        correlationId,
                        buildAuthHeaders(request)
                    );
                    return reply.send(response);
                } catch (error: any) {
                    request.log.error({
                        correlationId,
                        error: error.message,
                        stack: error.stack,
                    }, 'Error proxying search request');

                    // Forward structured errors from search-service
                    if (error.jsonBody) {
                        return reply.status(error.statusCode || 500).send(error.jsonBody);
                    }

                    return reply.status(error.statusCode || 500).send({
                        error: {
                            message: error.message || 'Internal server error',
                            code: error.code || 'INTERNAL_ERROR',
                        },
                    });
                }
            }
        );
    }
    ```

    **4. Update `services/api-gateway/src/routes/v2/routes.ts`:**
    Add import and registration of search routes:
    - Add import: `import { registerSearchRoutes } from './search';`
    - Add call in `registerV2GatewayRoutes` function body: `registerSearchRoutes(app, services);`
    Place it alphabetically after `registerPresenceRoutes`.

    These changes wire the search endpoint through the gateway. The gateway:
    - Requires Clerk JWT authentication (via requireAuth preHandler)
    - Extracts x-clerk-user-id from JWT via buildAuthHeaders
    - Forwards all query parameters (q, mode, entity_type, page, limit) to search-service
    - Returns search-service response as-is (no transformation)
    - Forwards structured error responses from search-service (400 validation errors, etc.)
  </action>
  <verify>
    - `pnpm --filter @splits-network/api-gateway typecheck` passes
    - `services/api-gateway/src/routes/v2/search.ts` exists
    - `services/api-gateway/src/routes/v2/routes.ts` imports and calls `registerSearchRoutes`
    - `services/api-gateway/src/index.ts` registers 'search' service at port 3012
    - `services/api-gateway/src/routes/v2/common.ts` includes 'search' in ServiceName type
    - Route uses `requireAuth()` preHandler
    - Route uses `buildAuthHeaders(request)` to forward auth headers
    - Route uses `buildQueryString` to forward query params
    - Error handling forwards structured errors from search-service
  </verify>
  <done>
    API gateway fully wired to search-service:
    - search-service registered at SEARCH_SERVICE_URL (default http://localhost:3012)
    - GET /api/v2/search proxied to search-service with auth headers and query params
    - Authentication required (401 if no JWT)
    - Structured errors from search-service forwarded to client
    - Gateway typecheck passes with no errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify end-to-end search API wiring</name>
  <files>
    (no new files — verification only)
  </files>
  <action>
    Run the following verification checks to confirm the entire Phase 2 search API is correctly wired:

    1. **TypeScript compilation** — Both services compile:
       - `pnpm --filter @splits-network/search-service build`
       - `pnpm --filter @splits-network/api-gateway typecheck`

    2. **File inventory** — Confirm all Phase 2 artifacts exist:
       - `services/search-service/package.json`
       - `services/search-service/tsconfig.json`
       - `services/search-service/src/index.ts`
       - `services/search-service/src/v2/search/types.ts`
       - `services/search-service/src/v2/search/repository.ts`
       - `services/search-service/src/v2/search/service.ts`
       - `services/search-service/src/v2/routes.ts`
       - `services/api-gateway/src/routes/v2/search.ts`

    3. **Code audit** — Grep for critical patterns:
       - `grep -r "resolveAccessContext\|AccessContextResolver" services/search-service/` confirms access control is wired
       - `grep -r "schema('search')" services/search-service/` confirms search schema usage
       - `grep -r "textSearch" services/search-service/` confirms FTS usage
       - `grep -r "VALIDATION_ERROR" services/search-service/` confirms validation error handling
       - `grep -r "x-clerk-user-id" services/search-service/` confirms auth header reading
       - `grep -r "search" services/api-gateway/src/routes/v2/routes.ts` confirms gateway registration

    4. **Phase success criteria validation** — Verify all 4 success criteria from ROADMAP.md are addressed:
       - SC1: GET /v2/search?q=query&mode=typeahead returns top 5 per entity type — CHECK repository.searchTypeahead limits to 5
       - SC2: GET /v2/search?q=query&mode=full returns paginated { data, pagination } — CHECK service uses buildPaginationResponse
       - SC3: Role-based access control — CHECK repository uses AccessContextResolver
       - SC4: Malformed queries return validation errors — CHECK service validates q length >= 2

    If any check fails, fix the issue before completing.
  </action>
  <verify>
    All 4 verification checks pass. All 4 phase success criteria are addressed by the implementation.
  </verify>
  <done>
    End-to-end search API verified:
    - Both services compile with no TypeScript errors
    - All 8 required files exist
    - Access control, FTS, validation, and auth patterns confirmed via grep
    - All 4 Phase 2 success criteria addressed
    - Phase 2 complete: Search API ready for frontend integration in Phase 3
  </done>
</task>

</tasks>

<verification>
1. `pnpm --filter @splits-network/search-service build` — Compiles successfully
2. `pnpm --filter @splits-network/api-gateway typecheck` — No type errors
3. Gateway registers search-service at port 3012
4. Gateway proxies GET /api/v2/search to search-service
5. Gateway requires auth for search endpoint
6. Gateway forwards query params and auth headers
7. All Phase 2 success criteria from ROADMAP addressed
</verification>

<success_criteria>
- API gateway starts and registers search service
- GET /api/v2/search requests proxied through gateway to search-service
- Auth required for search endpoints
- Query params forwarded correctly
- Error responses forwarded from search-service
- Both services compile without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-search-api/02-02-SUMMARY.md`
</output>
