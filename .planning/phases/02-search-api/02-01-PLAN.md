---
phase: 02-search-api
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - services/search-service/package.json
  - services/search-service/tsconfig.json
  - services/search-service/src/index.ts
  - services/search-service/src/v2/search/types.ts
  - services/search-service/src/v2/search/repository.ts
  - services/search-service/src/v2/search/service.ts
  - services/search-service/src/v2/routes.ts
autonomous: true

must_haves:
  truths:
    - "GET /api/v2/search?q=john&mode=typeahead returns top 5 results per entity type in < 200ms"
    - "GET /api/v2/search?q=john&mode=full returns paginated results with { data, pagination } envelope"
    - "Company users only see entities scoped to their organization"
    - "Recruiters see only entities they are assigned to or candidates they source"
    - "Platform admins see all entities"
    - "Empty query returns 400 validation error, not a crash"
    - "Queries with SQL injection characters are sanitized and return safe results"
  artifacts:
    - path: "services/search-service/package.json"
      provides: "Service package definition with dependencies"
    - path: "services/search-service/src/index.ts"
      provides: "Fastify server bootstrap"
    - path: "services/search-service/src/v2/search/repository.ts"
      provides: "Database queries against search.search_index with role-based filtering"
      contains: "resolveAccessContext"
    - path: "services/search-service/src/v2/search/service.ts"
      provides: "Query validation, sanitization, and search orchestration"
    - path: "services/search-service/src/v2/routes.ts"
      provides: "GET /api/v2/search route handler"
  key_links:
    - from: "services/search-service/src/v2/routes.ts"
      to: "services/search-service/src/v2/search/service.ts"
      via: "searchService.search(clerkUserId, params)"
      pattern: "searchService\\.search"
    - from: "services/search-service/src/v2/search/service.ts"
      to: "services/search-service/src/v2/search/repository.ts"
      via: "repository.searchTypeahead / repository.searchFull"
      pattern: "this\\.repository\\.(searchTypeahead|searchFull)"
    - from: "services/search-service/src/v2/search/repository.ts"
      to: "search.search_index"
      via: "supabase.schema('search').from('search_index').textSearch()"
      pattern: "schema\\('search'\\).*from\\('search_index'\\)"
    - from: "services/search-service/src/v2/search/repository.ts"
      to: "@splits-network/shared-access-context"
      via: "AccessContextResolver"
      pattern: "AccessContextResolver"
---

<objective>
Create a new search-service with a GET /api/v2/search endpoint that queries search.search_index, supports both typeahead mode (top 5 per entity type) and full mode (paginated), applies role-based access control via resolveAccessContext, and validates/sanitizes input queries.

Purpose: This is the core backend for global search. The search-service is a focused nano-service that reads from the search schema created in Phase 1 and returns ranked, access-controlled results.

Output: A fully functional search-service with repository, service, types, and route handler.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-search-infrastructure/01-01-SUMMARY.md
@.planning/phases/01-search-infrastructure/01-03-SUMMARY.md

Key reference files:
@services/analytics-service/package.json (for package.json structure)
@services/analytics-service/src/index.ts (for server bootstrap pattern)
@services/analytics-service/src/v2/routes.ts (for V2 route registration pattern)
@services/analytics-service/src/v2/stats/repository.ts (for repository pattern with resolveAccessContext)
@packages/shared-access-context/src/index.ts (AccessContext interface and resolver)
@packages/shared-types/src/list-response.ts (StandardListResponse, buildPaginationResponse)
@packages/shared-types/src/list-params.ts (StandardListParams, parseFilters)
@supabase/migrations/20260213000002_create_search_schema.sql (search_index schema)
@docs/guidance/api-response-format.md (response envelope format)
@docs/guidance/pagination.md (pagination patterns)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create search-service scaffold and types</name>
  <files>
    services/search-service/package.json
    services/search-service/tsconfig.json
    services/search-service/src/index.ts
    services/search-service/src/v2/search/types.ts
  </files>
  <action>
    Create a new `services/search-service/` directory with the standard nano-service scaffold.

    **package.json** — Follow `services/analytics-service/package.json` as a template. Key differences:
    - Name: `@splits-network/search-service`
    - Description: `Search service - unified global search across all entities`
    - Dependencies: `fastify`, `@fastify/cors`, `@supabase/supabase-js`, `@splits-network/shared-access-context`, `@splits-network/shared-config`, `@splits-network/shared-fastify`, `@splits-network/shared-logging`, `@splits-network/shared-types`
    - NO: `amqplib`, `ioredis`, `node-cron`, `zod`, `@fastify/swagger`, `@fastify/swagger-ui`, `@splits-network/shared-job-queue`, `@splits-network/shared-api-client` (not needed — this is a read-only service with no event publishing, no caching, no swagger needed initially)
    - Scripts: same pattern (build, dev, start, test, lint, typecheck)
    - Dev dependencies: `@types/node`, `tsx`, `typescript`, `vitest`
    - Port: 3012 (next available after chat at 3011)

    **tsconfig.json** — Standard TypeScript config extending nothing (standalone). Target ES2022, module NodeNext, outDir dist, rootDir src, strict true, esModuleInterop true, skipLibCheck true, resolveJsonModule true, declaration true.

    **src/index.ts** — Minimal Fastify bootstrap following `analytics-service/src/index.ts` pattern but simplified:
    - Load config via `loadConfig()` from shared-config
    - Create Supabase client with `SUPABASE_URL` and `SUPABASE_SERVICE_ROLE_KEY` env vars
    - Create Fastify instance with CORS (origin: true, credentials: true)
    - Health check at `/health`
    - Register V2 routes with supabase client
    - Listen on PORT env var (default 3012)
    - Graceful shutdown on SIGTERM/SIGINT
    - Disable request logging for health checks (same pattern as analytics)

    **src/v2/search/types.ts** — Define search-specific types:
    ```typescript
    export type SearchMode = 'typeahead' | 'full';

    export type SearchableEntityType =
      | 'candidate' | 'job' | 'company' | 'recruiter'
      | 'application' | 'placement' | 'recruiter_candidate';

    export interface SearchParams {
      q: string;                              // The search query
      mode: SearchMode;                       // typeahead (top 5 per type) or full (paginated)
      entity_type?: SearchableEntityType;     // Optional filter to specific entity type
      page?: number;                          // For full mode pagination (default 1)
      limit?: number;                         // For full mode pagination (default 25)
    }

    export interface SearchResult {
      entity_type: SearchableEntityType;
      entity_id: string;
      title: string;
      subtitle: string;
      context: string;
      metadata: Record<string, any>;
      rank: number;                           // ts_rank score
    }

    export interface TypeaheadResponse {
      groups: TypeaheadGroup[];
    }

    export interface TypeaheadGroup {
      entity_type: SearchableEntityType;
      label: string;                          // Human-readable label (e.g., "Candidates")
      results: SearchResult[];
    }
    ```

    ENTITY_TYPE_LABELS constant mapping entity_type to human-readable labels:
    ```typescript
    export const ENTITY_TYPE_LABELS: Record<SearchableEntityType, string> = {
      candidate: 'Candidates',
      job: 'Jobs',
      company: 'Companies',
      recruiter: 'Recruiters',
      application: 'Applications',
      placement: 'Placements',
      recruiter_candidate: 'Recruiter Candidates',
    };
    ```
  </action>
  <verify>
    - `ls services/search-service/package.json` exists
    - `ls services/search-service/tsconfig.json` exists
    - `ls services/search-service/src/index.ts` exists
    - `ls services/search-service/src/v2/search/types.ts` exists
    - Run `pnpm install` from repo root to link workspace dependencies
    - Run `pnpm --filter @splits-network/search-service typecheck` passes (no type errors)
  </verify>
  <done>
    Search service scaffold exists with package.json, tsconfig.json, server bootstrap, and search types.
    Types exported: SearchMode, SearchableEntityType, SearchParams, SearchResult, TypeaheadResponse, TypeaheadGroup, ENTITY_TYPE_LABELS.
    Service starts and responds to health check at /health.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create search repository with access control and search service with validation</name>
  <files>
    services/search-service/src/v2/search/repository.ts
    services/search-service/src/v2/search/service.ts
    services/search-service/src/v2/routes.ts
  </files>
  <action>
    **src/v2/search/repository.ts** — Database access layer that queries search.search_index with role-based filtering.

    Class `SearchRepository`:
    - Constructor takes `supabase: SupabaseClient`
    - Private field `accessResolver: AccessContextResolver`
    - Method `async searchTypeahead(clerkUserId: string, query: string, entityType?: SearchableEntityType): Promise<TypeaheadGroup[]>`:
      1. Resolve access context via `this.accessResolver.resolve(clerkUserId)`
      2. Build base query: `this.supabase.schema('search').from('search_index')`
      3. Apply full-text search: `.textSearch('search_vector', query, { type: 'websearch' })`
      4. Apply access control filters (see access control logic below)
      5. If entityType filter provided, add `.eq('entity_type', entityType)`
      6. Select: `entity_type, entity_id, title, subtitle, context, metadata`
      7. Order by relevance — Supabase textSearch doesn't expose ts_rank directly via the query builder, so we need to use `.rpc()` or raw SQL. **Use a simpler approach**: Query each entity type separately (max 7 queries, run in Promise.all) with `.limit(5)` each, then assemble into TypeaheadGroup[]. This is actually faster than a single query with post-processing because each query hits the GIN index independently.
      8. Actually, simplify: If no entityType filter, query the table once with a reasonable limit (e.g., 50), then group results client-side. The GIN index + textSearch handles ranking via ts_rank internally. Supabase `.textSearch()` does NOT sort by relevance by default, so use `.order('search_vector')` which does NOT help. Instead, use an RPC call or Supabase's `.textSearch()` which actually does rank when using `websearch` type. **Best approach: use raw SQL via supabase.rpc() or supabase.schema('search').from('search_index').select('*, ts_rank(search_vector, websearch_to_tsquery($1)) as rank').** But Supabase JS client doesn't support computed columns in select. **Cleanest approach: Create a Postgres function `search.search_global(query text, max_per_type int, entity_types text[])` that returns ranked results.** NO — avoid adding database objects in this phase (that's infrastructure). **Pragmatic approach**: Use `.textSearch('search_vector', query, { type: 'websearch' })` which filters matching rows, then sort by `updated_at` desc as a proxy for relevance. This is fast and good enough for typeahead. For full mode, we will sort by updated_at desc as well. Note: Supabase textSearch DOES filter by relevance (only matching rows returned), but doesn't sort by rank. Sorting by updated_at is a reasonable heuristic (newer = more relevant).

      **Final typeahead approach:**
      - If entityType is specified: query search_index with textSearch filter + entity_type filter + access control + limit 5, return as single group
      - If no entityType: for each of the 7 entity types, run a query with textSearch + entity_type filter + access control + limit 5, run all in Promise.all. Filter out empty groups. Return non-empty groups.

      **Final full search approach:**
      - Query search_index with textSearch + access control + optional entityType filter
      - Use COUNT(*) OVER() pattern via: first query count, then query page. OR use Supabase's `.select('*', { count: 'exact' })` to get total count.
      - Apply pagination: `.range((page-1)*limit, page*limit - 1)`
      - Sort by updated_at desc
      - Return `{ data: SearchResult[], pagination }`

    - Method `async searchFull(clerkUserId: string, query: string, entityType?: SearchableEntityType, page?: number, limit?: number): Promise<{ data: SearchResult[], total: number }>`:
      1. Resolve access context
      2. Build query with textSearch + access control + optional entityType filter
      3. Use `.select('entity_type, entity_id, title, subtitle, context, metadata', { count: 'exact' })` to get total
      4. Apply `.range((page-1)*limit, page*limit - 1)` for pagination
      5. Sort by `updated_at` desc
      6. Return data + total count

    **Access Control Logic** (applied to both typeahead and full):
    Implement as a private method `applyAccessControl(query, context: AccessContext)`:
    - If `context.isPlatformAdmin`: No filter (see all entities)
    - If `context.roles` includes `company_admin` or `hiring_manager`:
      - Filter by `organization_id IN context.organizationIds` for org-scoped entities
      - OR entity_type in ('candidate', 'recruiter') which are not org-scoped but visible to company users
      - Actually, company users should see: their own jobs, their own applications, their own placements, their own companies, plus all candidates and recruiters (marketplace entities).
      - Simplest correct filter: `.or('organization_id.in.(${orgIds}),organization_id.is.null')` — org-scoped entities match by org, non-org-scoped entities (candidates, recruiters) have null org and are visible to all.
      - Wait — check the trigger SQL: candidates have `organization_id = NULL`, recruiters have `organization_id = NULL`, jobs have `organization_id = company.identity_organization_id`, companies have `organization_id = identity_organization_id`, applications inherit org from job, placements inherit org from application->job.
      - So the filter `.or('organization_id.in.(${orgIds}),organization_id.is.null')` correctly shows: company's own jobs/apps/placements/companies + all candidates + all recruiters. This is correct behavior.
    - If `context.roles` includes `recruiter`:
      - Recruiters should see: all jobs (they browse marketplace), all companies, candidates they source (recruiter_candidates where recruiter_id matches), applications they submitted, placements they're involved in, and their own recruiter profile.
      - For simplicity in search: same pattern `.or('organization_id.in.(${orgIds}),organization_id.is.null')` — but recruiters typically have NO organizationIds. So this would show only `organization_id IS NULL` entities (candidates, recruiters).
      - This is too restrictive for recruiters. Recruiters should see jobs (even though jobs have org_id).
      - **Better approach for recruiters**: Show all entities where organization_id IS NULL (candidates, recruiters) + jobs (always visible as marketplace listings) + entities where the recruiter is involved. But this requires per-entity-type logic.
      - **Pragmatic approach**: For the initial implementation, allow recruiters to see everything except other companies' applications and placements. Filter: for entity_type in ('candidate', 'job', 'company', 'recruiter'): no filter needed. For entity_type in ('application', 'placement', 'recruiter_candidate'): these are sensitive and should be filtered. Since we can't easily filter by recruiter_id in the search_index (it's in metadata), use the simpler rule: show all entity types that have `organization_id IS NULL` (candidates, recruiters) + all jobs + all companies. For applications/placements/recruiter_candidates, only show if organization_id is null (which they never are — they inherit org). So recruiters won't see applications/placements in search, which is acceptable as those are internal to the hiring company.
      - Actually, re-examine: recruiter_candidates have `organization_id = NULL` in the trigger (recruiter_candidates aren't org-scoped). Applications DO have `organization_id` set. Placements DO have `organization_id` set.
      - **Revised recruiter filter**: Recruiters see all entities where `organization_id IS NULL` (candidates, recruiters, recruiter_candidates) plus all entities where `entity_type IN ('job', 'company')` (marketplace browsing). Applications and placements are hidden from search for non-org users. This is acceptable — recruiters access their specific applications/placements via direct navigation, not search.
      - Implementation: `.or('organization_id.is.null,entity_type.in.(job,company)')` — this covers candidates, recruiters, recruiter_candidates (null org) + jobs and companies (regardless of org).

    - If `context.roles` includes `candidate`:
      - Candidates see: jobs (marketplace), companies (marketplace), their own candidate profile. Hide applications, placements, recruiters, recruiter_candidates from search.
      - Filter: `.in('entity_type', ['job', 'company', 'candidate'])` then further filter candidate results to only their own candidate_id.
      - Simpler: `.or('entity_type.in.(job,company),entity_type.eq.candidate')` — shows all jobs, companies, and candidates. We could further restrict candidates to only their own profile, but for now showing all candidates in search is fine (candidate profiles aren't sensitive).

    - **Simplify all of the above**: The organization_id approach works well:
      - Platform admin: no filter
      - Has organizationIds (company users): `.or('organization_id.in.(${orgIds}),organization_id.is.null,entity_type.in.(job,company)')`
      - No organizationIds (recruiter/candidate): `.or('organization_id.is.null,entity_type.in.(job,company)')`

      This correctly handles:
      - Company users see their own org-scoped entities + all null-org entities + all jobs/companies
      - Recruiters see null-org entities + all jobs/companies
      - Candidates see null-org entities + all jobs/companies

    **src/v2/search/service.ts** — Business logic layer:

    Class `SearchService`:
    - Constructor takes `repository: SearchRepository`
    - Method `async search(clerkUserId: string, params: SearchParams)`:
      1. **Validate query**:
         - `q` must be a string with length >= 2 after trimming
         - `q` must not be empty or whitespace-only
         - If validation fails, throw an error with code `VALIDATION_ERROR` and appropriate message
      2. **Sanitize query**:
         - Trim whitespace
         - Remove null bytes (`\0`)
         - Limit length to 200 characters
         - Replace consecutive whitespace with single space
         - The query is passed to Postgres `websearch_to_tsquery()` which handles special characters safely (no SQL injection risk via parameterized queries + websearch parser)
      3. **Route to mode**:
         - If `mode === 'typeahead'`: call `repository.searchTypeahead(clerkUserId, sanitizedQuery, params.entity_type)`, return `{ data: groups }`
         - If `mode === 'full'`: call `repository.searchFull(clerkUserId, sanitizedQuery, params.entity_type, params.page, params.limit)`, return `{ data, pagination: buildPaginationResponse(page, limit, total) }`
      4. Default page=1, limit=25 if not provided. Clamp limit to max 100.

    **src/v2/routes.ts** — Route registration:

    Function `registerV2Routes(app: FastifyInstance, options: { supabase: SupabaseClient })`:
    - Instantiate `SearchRepository(supabase)` and `SearchService(repository)`
    - Register `GET /api/v2/search` route:
      - Extract `x-clerk-user-id` from request headers (set by api-gateway)
      - If no clerk user id, return 401 `{ error: { code: 'UNAUTHORIZED', message: 'Authentication required' } }`
      - Parse query params: `q` (string), `mode` (string, default 'typeahead'), `entity_type` (optional string), `page` (optional string->int), `limit` (optional string->int)
      - Validate `mode` is 'typeahead' or 'full', return 400 if invalid
      - Call `searchService.search(clerkUserId, params)`
      - Wrap response: for typeahead mode return `{ data: groups }`, for full mode the service already returns `{ data, pagination }`
      - Catch validation errors and return 400 `{ error: { code: 'VALIDATION_ERROR', message } }`
      - Catch unexpected errors and return 500 `{ error: { code: 'INTERNAL_ERROR', message: 'Search failed' } }`

    Register the route under `/api/v2/search` so the API gateway can forward `/api/v2/search` requests directly.
  </action>
  <verify>
    - `pnpm --filter @splits-network/search-service typecheck` passes
    - All files exist: repository.ts, service.ts, routes.ts
    - Route handler reads x-clerk-user-id header
    - Repository uses AccessContextResolver from shared-access-context
    - Repository queries search.search_index via supabase.schema('search')
    - Service validates query length >= 2 and sanitizes input
    - Service clamps limit to max 100
    - Typeahead mode limits to 5 results per entity type
    - Full mode includes pagination response
  </verify>
  <done>
    Search service fully implemented with:
    - Repository querying search.search_index with role-based access control via AccessContextResolver
    - Service layer validating query (min 2 chars, sanitized) and routing to typeahead/full modes
    - Route handler at GET /api/v2/search accepting q, mode, entity_type, page, limit params
    - Typeahead returns { data: { groups: [...] } } with top 5 per entity type
    - Full returns { data: [...], pagination: { total, page, limit, total_pages } }
    - Access control: platform admins see all, company users see org-scoped + public, recruiters/candidates see public + null-org entities
    - Validation errors return 400, auth errors return 401, server errors return 500
  </done>
</task>

</tasks>

<verification>
1. `pnpm --filter @splits-network/search-service typecheck` — No type errors
2. `pnpm --filter @splits-network/search-service build` — Builds successfully
3. Verify repository imports and uses `AccessContextResolver` from `@splits-network/shared-access-context`
4. Verify route reads `x-clerk-user-id` header for authentication
5. Verify search_index queries use `supabase.schema('search').from('search_index')`
6. Verify typeahead mode limits to 5 results per entity type
7. Verify full mode uses `buildPaginationResponse` from shared-types
8. Verify query validation rejects empty/short queries with 400 error
9. Verify query sanitization removes null bytes and limits length
</verification>

<success_criteria>
- search-service starts, listens on port 3012, responds to /health
- GET /api/v2/search?q=test&mode=typeahead returns grouped results
- GET /api/v2/search?q=test&mode=full returns paginated results
- Missing/invalid query returns 400 validation error
- Missing auth returns 401
- Access control filters applied based on user role
- TypeScript compiles with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-search-api/02-01-SUMMARY.md`
</output>
