---
phase: 12-oauth2-provider
plan: 03
type: execute
wave: 2
depends_on: []
files_modified:
  - services/api-gateway/src/index.ts
  - services/api-gateway/src/routes/v2/gpt.ts
  - services/api-gateway/src/routes/v2/routes.ts
  - services/api-gateway/src/routes/v2/common.ts
autonomous: true

must_haves:
  truths:
    - "api-gateway registers gpt-service in ServiceRegistry"
    - "GET/POST requests to /api/v1/gpt/* are proxied to gpt-service"
    - "Clerk auth is bypassed for /api/v1/gpt/* routes"
    - "ChatGPT origins are allowed in CORS for OAuth endpoints"
  artifacts:
    - path: "services/api-gateway/src/routes/v2/gpt.ts"
      provides: "GPT proxy route registration"
      contains: "registerGptRoutes"
    - path: "services/api-gateway/src/index.ts"
      provides: "gpt-service registered in ServiceRegistry and Clerk bypass for /api/v1/gpt/*"
      contains: "gpt"
  key_links:
    - from: "services/api-gateway/src/routes/v2/gpt.ts"
      to: "services/gpt-service/src/v2/routes.ts"
      via: "HTTP proxy through ServiceClient"
      pattern: "services.get.*gpt"
    - from: "services/api-gateway/src/index.ts"
      to: "services/api-gateway/src/routes/v2/gpt.ts"
      via: "registerGptRoutes import and call"
      pattern: "registerGptRoutes"
---

<objective>
Add api-gateway routing to proxy /api/v1/gpt/* requests to gpt-service with Clerk auth bypass.

Purpose: ChatGPT OAuth and API requests use GPT-issued tokens, not Clerk JWTs. The gateway must route these to gpt-service without requiring Clerk authentication. gpt-service handles its own token validation.

Output: GPT proxy route file, updated gateway index with gpt-service registration and auth bypass.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-oauth2-provider/12-CONTEXT.md
@services/api-gateway/src/index.ts
@services/api-gateway/src/routes/v2/routes.ts
@services/api-gateway/src/routes/v2/common.ts
@services/api-gateway/src/clients.ts
@services/api-gateway/src/auth.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Register gpt-service and create GPT proxy routes</name>
  <files>
    services/api-gateway/src/routes/v2/gpt.ts
    services/api-gateway/src/routes/v2/routes.ts
    services/api-gateway/src/routes/v2/common.ts
    services/api-gateway/src/index.ts
  </files>
  <action>
**1. Register gpt-service in ServiceRegistry** (`services/api-gateway/src/index.ts`):
Add alongside existing service registrations (around line 394):
```
services.register('gpt', process.env.GPT_SERVICE_URL || 'http://localhost:3014');
```
Use port 3014 as default (next available after chat=3011, search=3013).

**2. Add 'gpt' to ServiceName type** (`services/api-gateway/src/routes/v2/common.ts`):
Add `'gpt'` to the `ServiceName` union type.

**3. Create GPT proxy routes** (`services/api-gateway/src/routes/v2/gpt.ts`):
Create a new route file that registers proxy routes for GPT OAuth and API endpoints. These routes do NOT use `requireAuth()` -- gpt-service handles its own authentication.

```typescript
import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';
import { ServiceRegistry } from '../../clients';
import { getCorrelationId, buildQueryString } from './common';

export function registerGptRoutes(app: FastifyInstance, services: ServiceRegistry) {
    const gptClient = () => services.get('gpt');

    // OAuth authorize endpoint (browser redirect from ChatGPT)
    // GET /api/v1/gpt/oauth/authorize -> gpt-service /api/v2/oauth/authorize
    app.get('/api/v1/gpt/oauth/authorize', async (request: FastifyRequest, reply: FastifyReply) => {
        const correlationId = getCorrelationId(request);
        const queryString = buildQueryString(request.query as Record<string, any>);
        const path = queryString ? `/api/v2/oauth/authorize?${queryString}` : '/api/v2/oauth/authorize';
        const data = await gptClient().get(path, undefined, correlationId);
        return reply.send(data);
    });

    // OAuth token endpoint (POST, form-urlencoded from ChatGPT)
    // POST /api/v1/gpt/oauth/token -> gpt-service /api/v2/oauth/token
    app.post('/api/v1/gpt/oauth/token', async (request: FastifyRequest, reply: FastifyReply) => {
        const correlationId = getCorrelationId(request);
        const data = await gptClient().post('/api/v2/oauth/token', request.body, correlationId);
        return reply.send(data);
    });

    // OAuth revoke endpoint
    // POST /api/v1/gpt/oauth/revoke -> gpt-service /api/v2/oauth/revoke
    app.post('/api/v1/gpt/oauth/revoke', async (request: FastifyRequest, reply: FastifyReply) => {
        const correlationId = getCorrelationId(request);
        // Pass through Authorization header for GPT token validation
        const headers: Record<string, string> = {};
        if (request.headers.authorization) {
            headers['authorization'] = request.headers.authorization;
        }
        const data = await gptClient().post('/api/v2/oauth/revoke', request.body, correlationId, headers);
        return reply.send(data);
    });

    // Wildcard catch-all for future GPT API endpoints (Phase 13)
    // GET /api/v1/gpt/* -> gpt-service /api/v2/*
    app.get('/api/v1/gpt/:path(.*)', async (request: FastifyRequest, reply: FastifyReply) => {
        const { path } = request.params as { path: string };
        const correlationId = getCorrelationId(request);
        const queryString = buildQueryString(request.query as Record<string, any>);
        const servicePath = queryString ? `/api/v2/${path}?${queryString}` : `/api/v2/${path}`;
        const headers: Record<string, string> = {};
        if (request.headers.authorization) {
            headers['authorization'] = request.headers.authorization;
        }
        const data = await gptClient().get(servicePath, undefined, correlationId, headers);
        return reply.send(data);
    });

    // POST wildcard for future GPT write endpoints (Phase 13)
    app.post('/api/v1/gpt/:path(.*)', async (request: FastifyRequest, reply: FastifyReply) => {
        const { path } = request.params as { path: string };
        const correlationId = getCorrelationId(request);
        const headers: Record<string, string> = {};
        if (request.headers.authorization) {
            headers['authorization'] = request.headers.authorization;
        }
        const data = await gptClient().post(`/api/v2/${path}`, request.body, correlationId, headers);
        return reply.send(data);
    });
}
```

Note: The explicit OAuth routes are registered BEFORE the wildcard catch-all routes so Fastify matches them first. The wildcards will handle Phase 13 GPT API endpoints.

Important: Pass through the `Authorization` header from the request to gpt-service for GPT token validation. Do NOT pass `buildAuthHeaders(request)` since these requests don't have Clerk auth context.

**4. Register GPT routes in gateway** (`services/api-gateway/src/routes/v2/routes.ts`):
Import `registerGptRoutes` and call it alongside other route registrations. GPT routes don't need `eventPublisher`, `redis`, or `supabase` -- they're pure proxies.

**5. Add Clerk auth bypass for /api/v1/gpt/* routes** (`services/api-gateway/src/index.ts`):
In the `onRequest` auth hook, add a bypass BEFORE the `if (request.url.startsWith('/api/'))` check (around line 370):
```typescript
// Skip Clerk auth for GPT routes (gpt-service handles its own token validation)
if (request.url.startsWith('/api/v1/gpt/')) {
    return;
}
```
  </action>
  <verify>
Read each modified file and confirm:
1. gpt-service registered in ServiceRegistry with port 3014
2. 'gpt' added to ServiceName union
3. gpt.ts proxy routes exist for /api/v1/gpt/oauth/* and wildcard
4. registerGptRoutes imported and called in routes.ts
5. /api/v1/gpt/* bypasses Clerk auth in index.ts onRequest hook
  </verify>
  <done>api-gateway proxies /api/v1/gpt/* requests to gpt-service without Clerk authentication. Authorization header is passed through for GPT token validation.</done>
</task>

<task type="auto">
  <name>Task 2: Add CORS configuration for ChatGPT origins</name>
  <files>services/api-gateway/src/index.ts</files>
  <action>
The current CORS configuration in api-gateway uses `origin: true` in development (allows all) and `CORS_ORIGIN` env var in production. For ChatGPT to make OAuth requests:

1. In the `allowedOrigins` production configuration, ensure ChatGPT origins are included. The ChatGPT OAuth flow works via browser redirects (not CORS XHR), so the main CORS need is for the token endpoint which ChatGPT calls server-to-server.

2. Actually, ChatGPT's OAuth flow uses browser redirects (302) for authorize and server-to-server POST for token exchange. Server-to-server calls are NOT subject to CORS. Browser redirects are also not CORS-constrained.

3. Therefore, no CORS changes are strictly needed for the OAuth flow itself. However, for future GPT API endpoints (Phase 13) which ChatGPT calls via fetch, we should add a comment noting that `https://chat.openai.com` and `https://chatgpt.com` should be added to `CORS_ORIGIN` in production when deploying.

Add a comment in the CORS configuration section (around line 38-44) noting:
```typescript
// Note: For GPT Actions (Phase 13+), add https://chat.openai.com and
// https://chatgpt.com to CORS_ORIGIN in production.
// OAuth flow uses redirects (not CORS), but GPT API calls need CORS.
```

This is intentionally minimal -- no code changes, just documentation for the deployment step. The development `origin: true` already handles all origins.
  </action>
  <verify>Read `services/api-gateway/src/index.ts` CORS section and confirm the comment is present.</verify>
  <done>CORS documentation added for ChatGPT origins. No code changes needed since development mode allows all origins and production CORS is env-var configured.</done>
</task>

</tasks>

<verification>
1. `services/api-gateway/src/routes/v2/gpt.ts` exists with registerGptRoutes function
2. ServiceRegistry has gpt-service at port 3014
3. Clerk auth bypassed for /api/v1/gpt/* paths
4. Authorization header forwarded from gateway to gpt-service
5. CORS comment added for ChatGPT origins
</verification>

<success_criteria>
api-gateway routes /api/v1/gpt/* to gpt-service, bypassing Clerk auth and passing through the Authorization header. Gateway compiles without errors.
</success_criteria>

<output>
After completion, create `.planning/phases/12-oauth2-provider/12-03-SUMMARY.md`
</output>
