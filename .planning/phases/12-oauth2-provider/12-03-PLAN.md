---
phase: 12-oauth2-provider
plan: 03
type: execute
wave: 2
depends_on: []
files_modified:
  - services/api-gateway/src/index.ts
  - services/api-gateway/src/routes/v2/gpt.ts
  - services/api-gateway/src/routes/v2/routes.ts
  - services/api-gateway/src/routes/v2/common.ts
autonomous: true

must_haves:
  truths:
    - "api-gateway registers gpt-service in ServiceRegistry"
    - "GET/POST requests to /api/v1/gpt/* are proxied to gpt-service"
    - "Clerk auth is bypassed for /api/v1/gpt/* routes"
    - "ChatGPT origins (chat.openai.com, chatgpt.com) are included in production CORS allowed origins"
  artifacts:
    - path: "services/api-gateway/src/routes/v2/gpt.ts"
      provides: "GPT proxy route registration"
      contains: "registerGptRoutes"
    - path: "services/api-gateway/src/index.ts"
      provides: "gpt-service registered in ServiceRegistry and Clerk bypass for /api/v1/gpt/*"
      contains: "gpt"
  key_links:
    - from: "services/api-gateway/src/routes/v2/gpt.ts"
      to: "services/gpt-service/src/v2/routes.ts"
      via: "HTTP proxy through ServiceClient"
      pattern: "services.get.*gpt"
    - from: "services/api-gateway/src/index.ts"
      to: "services/api-gateway/src/routes/v2/gpt.ts"
      via: "registerGptRoutes import and call"
      pattern: "registerGptRoutes"
---

<objective>
Add api-gateway routing to proxy /api/v1/gpt/* requests to gpt-service with Clerk auth bypass.

Purpose: ChatGPT OAuth and API requests use GPT-issued tokens, not Clerk JWTs. The gateway must route these to gpt-service without requiring Clerk authentication. gpt-service handles its own token validation.

Output: GPT proxy route file, updated gateway index with gpt-service registration and auth bypass.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-oauth2-provider/12-CONTEXT.md
@services/api-gateway/src/index.ts
@services/api-gateway/src/routes/v2/routes.ts
@services/api-gateway/src/routes/v2/common.ts
@services/api-gateway/src/clients.ts
@services/api-gateway/src/auth.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Register gpt-service and create GPT proxy routes</name>
  <files>
    services/api-gateway/src/routes/v2/gpt.ts
    services/api-gateway/src/routes/v2/routes.ts
    services/api-gateway/src/routes/v2/common.ts
    services/api-gateway/src/index.ts
  </files>
  <action>
**1. Register gpt-service in ServiceRegistry** (`services/api-gateway/src/index.ts`):
Add alongside existing service registrations (around line 394):
```
services.register('gpt', process.env.GPT_SERVICE_URL || 'http://localhost:3014');
```
Use port 3014 as default (next available after chat=3011, search=3013).

**2. Add 'gpt' to ServiceName type** (`services/api-gateway/src/routes/v2/common.ts`):
Add `'gpt'` to the `ServiceName` union type.

**3. Create GPT proxy routes** (`services/api-gateway/src/routes/v2/gpt.ts`):
Create a new route file that registers proxy routes for GPT OAuth and API endpoints. These routes do NOT use `requireAuth()` -- gpt-service handles its own authentication.

```typescript
import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';
import { ServiceRegistry } from '../../clients';
import { getCorrelationId, buildQueryString } from './common';

export function registerGptRoutes(app: FastifyInstance, services: ServiceRegistry) {
    const gptClient = () => services.get('gpt');

    // OAuth authorize endpoint (browser redirect from ChatGPT)
    // GET /api/v1/gpt/oauth/authorize -> gpt-service /api/v2/oauth/authorize
    app.get('/api/v1/gpt/oauth/authorize', async (request: FastifyRequest, reply: FastifyReply) => {
        const correlationId = getCorrelationId(request);
        const queryString = buildQueryString(request.query as Record<string, any>);
        const path = queryString ? `/api/v2/oauth/authorize?${queryString}` : '/api/v2/oauth/authorize';
        const data = await gptClient().get(path, undefined, correlationId);
        return reply.send(data);
    });

    // OAuth token endpoint (POST, form-urlencoded from ChatGPT)
    // POST /api/v1/gpt/oauth/token -> gpt-service /api/v2/oauth/token
    app.post('/api/v1/gpt/oauth/token', async (request: FastifyRequest, reply: FastifyReply) => {
        const correlationId = getCorrelationId(request);
        const data = await gptClient().post('/api/v2/oauth/token', request.body, correlationId);
        return reply.send(data);
    });

    // OAuth revoke endpoint
    // POST /api/v1/gpt/oauth/revoke -> gpt-service /api/v2/oauth/revoke
    app.post('/api/v1/gpt/oauth/revoke', async (request: FastifyRequest, reply: FastifyReply) => {
        const correlationId = getCorrelationId(request);
        // Pass through Authorization header for GPT token validation
        const headers: Record<string, string> = {};
        if (request.headers.authorization) {
            headers['authorization'] = request.headers.authorization;
        }
        const data = await gptClient().post('/api/v2/oauth/revoke', request.body, correlationId, headers);
        return reply.send(data);
    });

    // Wildcard catch-all for future GPT API endpoints (Phase 13)
    // GET /api/v1/gpt/* -> gpt-service /api/v2/*
    app.get('/api/v1/gpt/:path(.*)', async (request: FastifyRequest, reply: FastifyReply) => {
        const { path } = request.params as { path: string };
        const correlationId = getCorrelationId(request);
        const queryString = buildQueryString(request.query as Record<string, any>);
        const servicePath = queryString ? `/api/v2/${path}?${queryString}` : `/api/v2/${path}`;
        const headers: Record<string, string> = {};
        if (request.headers.authorization) {
            headers['authorization'] = request.headers.authorization;
        }
        const data = await gptClient().get(servicePath, undefined, correlationId, headers);
        return reply.send(data);
    });

    // POST wildcard for future GPT write endpoints (Phase 13)
    app.post('/api/v1/gpt/:path(.*)', async (request: FastifyRequest, reply: FastifyReply) => {
        const { path } = request.params as { path: string };
        const correlationId = getCorrelationId(request);
        const headers: Record<string, string> = {};
        if (request.headers.authorization) {
            headers['authorization'] = request.headers.authorization;
        }
        const data = await gptClient().post(`/api/v2/${path}`, request.body, correlationId, headers);
        return reply.send(data);
    });
}
```

Note: The explicit OAuth routes are registered BEFORE the wildcard catch-all routes so Fastify matches them first. The wildcards will handle Phase 13 GPT API endpoints.

Important: Pass through the `Authorization` header from the request to gpt-service for GPT token validation. Do NOT pass `buildAuthHeaders(request)` since these requests don't have Clerk auth context.

**4. Register GPT routes in gateway** (`services/api-gateway/src/routes/v2/routes.ts`):
Import `registerGptRoutes` and call it alongside other route registrations. GPT routes don't need `eventPublisher`, `redis`, or `supabase` -- they're pure proxies.

**5. Add Clerk auth bypass for /api/v1/gpt/* routes** (`services/api-gateway/src/index.ts`):
In the `onRequest` auth hook, add a bypass BEFORE the `if (request.url.startsWith('/api/'))` check (around line 370):
```typescript
// Skip Clerk auth for GPT routes (gpt-service handles its own token validation)
if (request.url.startsWith('/api/v1/gpt/')) {
    return;
}
```
  </action>
  <verify>
Read each modified file and confirm:
1. gpt-service registered in ServiceRegistry with port 3014
2. 'gpt' added to ServiceName union
3. gpt.ts proxy routes exist for /api/v1/gpt/oauth/* and wildcard
4. registerGptRoutes imported and called in routes.ts
5. /api/v1/gpt/* bypasses Clerk auth in index.ts onRequest hook
  </verify>
  <done>api-gateway proxies /api/v1/gpt/* requests to gpt-service without Clerk authentication. Authorization header is passed through for GPT token validation.</done>
</task>

<task type="auto">
  <name>Task 2: Add ChatGPT origins to CORS allowed origins</name>
  <files>services/api-gateway/src/index.ts</files>
  <action>
The current CORS configuration in api-gateway uses `origin: true` in development (allows all) and `CORS_ORIGIN` env var in production.

**Analysis of CORS needs:**
- OAuth authorize: browser redirect (302) -- no CORS needed
- OAuth token exchange: server-to-server POST from ChatGPT -- no CORS needed
- Phase 13 GPT API endpoints: ChatGPT calls via fetch from its domain -- CORS IS needed

While the OAuth flow itself (Phase 12) uses redirects and server-to-server calls that are not subject to CORS, Phase 13 GPT API endpoints WILL require CORS for ChatGPT origins. To avoid a deployment gap, add the ChatGPT origins now.

**Changes to make:**

1. In the CORS configuration section, add ChatGPT origins to the allowed origins list. The gateway uses `CORS_ORIGIN` env var for production. Update the CORS `origin` configuration to include ChatGPT domains alongside the env-var origins:

```typescript
// Add ChatGPT origins for GPT Actions API endpoints
const GPT_ORIGINS = ['https://chat.openai.com', 'https://chatgpt.com'];
```

2. In the CORS origin handler (the function that checks allowed origins), merge GPT_ORIGINS with the existing `CORS_ORIGIN` env var origins. If `origin` is currently a simple callback or array, update it to:
   - In development: keep `origin: true` (allows all -- no change)
   - In production: check if the request origin matches EITHER the CORS_ORIGIN env var values OR the GPT_ORIGINS array

3. If the current CORS setup uses `@fastify/cors` with a single origin string from env, update to accept an array. Example:
```typescript
const allowedOrigins = [
    ...(process.env.CORS_ORIGIN ? process.env.CORS_ORIGIN.split(',') : []),
    ...GPT_ORIGINS,
];
// Use origin callback: (origin, callback) => callback(null, allowedOrigins.includes(origin))
```

This ensures ChatGPT can make cross-origin requests to the GPT API endpoints when Phase 13 is deployed, without requiring a separate deployment/config change.
  </action>
  <verify>Read `services/api-gateway/src/index.ts` CORS section and confirm: (1) GPT_ORIGINS array includes chat.openai.com and chatgpt.com, (2) production CORS origin check includes GPT origins alongside env-var origins, (3) development mode still allows all origins.</verify>
  <done>ChatGPT origins (chat.openai.com, chatgpt.com) are included in the gateway CORS allowed origins for production. Development mode unchanged (allows all).</done>
</task>

</tasks>

<verification>
1. `services/api-gateway/src/routes/v2/gpt.ts` exists with registerGptRoutes function
2. ServiceRegistry has gpt-service at port 3014
3. Clerk auth bypassed for /api/v1/gpt/* paths
4. Authorization header forwarded from gateway to gpt-service
5. ChatGPT origins (chat.openai.com, chatgpt.com) added to production CORS allowed origins
</verification>

<success_criteria>
api-gateway routes /api/v1/gpt/* to gpt-service, bypassing Clerk auth and passing through the Authorization header. ChatGPT origins are configured in production CORS. Gateway compiles without errors.
</success_criteria>

<output>
After completion, create `.planning/phases/12-oauth2-provider/12-03-SUMMARY.md`
</output>
