---
phase: 12-oauth2-provider
plan: 02
type: tdd
wave: 2
depends_on: ["12-01"]
files_modified:
  - services/gpt-service/src/v2/oauth/oauth-service.ts
  - services/gpt-service/src/v2/oauth/oauth-service.test.ts
  - services/gpt-service/src/v2/oauth/types.ts
  - services/gpt-service/package.json
autonomous: true

must_haves:
  truths:
    - "Authorization codes are generated with PKCE challenge, scopes, redirect URI, and 5-minute TTL"
    - "Token exchange validates auth code, PKCE verifier, client credentials, and returns JWT access token + opaque refresh token"
    - "Refresh token rotation issues new access + refresh tokens and invalidates old refresh token"
    - "Replaying a rotated refresh token revokes ALL sessions for that user"
    - "Token revocation immediately invalidates a session's refresh token"
    - "JWT access tokens are signed with ES256 and contain sub, iss, aud, exp, iat, session_id, scopes claims"
    - "Access tokens are prefixed with gpt_at_, refresh tokens with gpt_rt_"
    - "Session limit of 5 per user is enforced during authorization"
  artifacts:
    - path: "services/gpt-service/src/v2/oauth/oauth-service.ts"
      provides: "OAuthService class with authorize, exchangeCode, refresh, revoke methods"
      min_lines: 150
    - path: "services/gpt-service/src/v2/oauth/oauth-service.test.ts"
      provides: "Test suite covering all OAuth flows"
      min_lines: 100
    - path: "services/gpt-service/src/v2/oauth/types.ts"
      provides: "OAuth type definitions, scope constants, error types"
      contains: "GPT_SCOPES"
  key_links:
    - from: "services/gpt-service/src/v2/oauth/oauth-service.ts"
      to: "supabase (gpt_authorization_codes, gpt_refresh_tokens, gpt_sessions)"
      via: "Supabase client queries"
      pattern: "supabase.*from.*gpt_"
    - from: "services/gpt-service/src/v2/oauth/oauth-service.ts"
      to: "packages/shared-config/src/index.ts"
      via: "GptConfig for EC key and TTLs"
      pattern: "ecPrivateKeyBase64|accessTokenExpiry"
---

<objective>
Build the OAuth2 core service with TDD: authorization code flow, PKCE, JWT access tokens (ES256), opaque refresh tokens with rotation, replay detection, and session management.

Purpose: This is the heart of Phase 12 -- the OAuthService class that all routes and middleware depend on. TDD ensures the security-critical token lifecycle logic is correct before wiring routes.

Output: Tested OAuthService class, OAuth types/constants, and test suite.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-oauth2-provider/12-CONTEXT.md
@.planning/phases/11-service-foundation/11-01-SUMMARY.md
@.planning/phases/11-service-foundation/11-02-SUMMARY.md
@services/gpt-service/src/index.ts
@services/gpt-service/src/v2/shared/events.ts
@packages/shared-config/src/index.ts
@supabase/migrations/20260220000001_create_gpt_oauth_tables.sql
</context>

<feature>
  <name>OAuthService - OAuth2 Authorization Code Flow with PKCE and JWT</name>
  <files>
    services/gpt-service/src/v2/oauth/types.ts
    services/gpt-service/src/v2/oauth/oauth-service.ts
    services/gpt-service/src/v2/oauth/oauth-service.test.ts
    services/gpt-service/package.json
  </files>
  <behavior>
    **Types (types.ts):**
    - `GPT_SCOPES` constant: `['jobs:read', 'applications:read', 'applications:write', 'resume:read']`
    - `GptScope` type: union of scope strings
    - `READ_SCOPES`: `['jobs:read', 'applications:read', 'resume:read']` (default initial consent)
    - `AuthorizeParams`: `{ clerkUserId, redirectUri, scopes, state, codeChallenge, codeChallengeMethod }`
    - `TokenExchangeParams`: `{ code, codeVerifier, clientId, clientSecret, redirectUri }`
    - `RefreshParams`: `{ refreshToken, clientId, clientSecret }`
    - `TokenResponse`: `{ access_token, token_type: 'Bearer', expires_in, refresh_token, scope }`
    - `OAuthError` class extending Error with `code` property (e.g., 'invalid_grant', 'invalid_client', 'session_limit_exceeded', 'invalid_scope')

    **OAuthService (oauth-service.ts):**

    Constructor takes: `supabase: SupabaseClient`, `gptConfig: GptConfig`, `eventPublisher: EventPublisher`, `logger: Logger`

    Methods and expected behavior:

    1. `authorize(params: AuthorizeParams) -> { code: string }`:
       - Validates scopes are subset of GPT_SCOPES
       - Checks session count for user (max 5) -- throws OAuthError('session_limit_exceeded') if at limit
       - Checks if user has existing session with identical or superset scopes -- if so, generates auth code immediately (returning user skip consent)
       - Generates random authorization code (crypto.randomBytes, 32 bytes, hex-encoded)
       - Inserts into gpt_authorization_codes: code, code_challenge, code_challenge_method, clerk_user_id, redirect_uri, scopes, expires_at (now + authCodeExpiry)
       - Publishes `gpt.oauth.authorize` event via EventPublisher
       - Returns `{ code }`

    2. `exchangeCode(params: TokenExchangeParams) -> TokenResponse`:
       - Validates client_id and client_secret against GptConfig
       - Looks up authorization code in DB (must be unused, not expired)
       - Validates PKCE: SHA256(codeVerifier) base64url-encoded must equal stored code_challenge
       - Validates redirect_uri matches stored redirect_uri
       - Marks auth code as used (set used_at)
       - Creates gpt_sessions row with clerk_user_id, scopes from auth code
       - Generates opaque refresh token (crypto.randomBytes, 48 bytes, hex-encoded, prefixed `gpt_rt_`)
       - Hashes refresh token with SHA-256 before storing
       - Inserts gpt_refresh_tokens: token_hash, clerk_user_id, expires_at (now + refreshTokenExpiry)
       - Links session to refresh_token_id
       - Updates session granted_scopes (union of previous granted_scopes + new scopes)
       - Signs JWT access token with ES256:
         - Header: `{ alg: 'ES256', typ: 'JWT' }`
         - Payload: `{ iss: 'splits-network-gpt', aud: 'gpt', sub: clerk_user_id, session_id: session.id, scopes: [...], iat: now, exp: now + accessTokenExpiry }`
         - Prefix the JWT with `gpt_at_`
       - Publishes `gpt.oauth.token_exchanged` event
       - Returns TokenResponse

    3. `refresh(params: RefreshParams) -> TokenResponse`:
       - Validates client credentials
       - Hashes incoming refresh token, looks up in DB
       - If token is found but revoked_at is set OR rotated_to is not null -> REPLAY DETECTED:
         - Revoke ALL sessions for that user (set revoked_at on all refresh tokens, remove all sessions)
         - Publish `gpt.oauth.replay_detected` event
         - Throw OAuthError('invalid_grant', 'Refresh token has been revoked')
       - If token not found or expired -> throw OAuthError('invalid_grant')
       - Token rotation:
         - Generate new refresh token (same pattern as above)
         - Insert new gpt_refresh_tokens row
         - Set old token's `rotated_to` to new token's ID and `revoked_at` to now
         - Update session's refresh_token_id to new token
         - Update session's last_active to now
       - Sign new JWT access token (same claims, session_id preserved)
       - Publish `gpt.oauth.token_refreshed` event
       - Return new TokenResponse

    4. `revoke(sessionId: string, clerkUserId: string) -> void`:
       - Validates session belongs to user
       - Sets revoked_at on the session's current refresh token
       - Deletes the session row
       - Publishes `gpt.oauth.session_revoked` event

    5. `revokeAllSessions(clerkUserId: string) -> void`:
       - Revokes all refresh tokens for user
       - Deletes all sessions for user
       - Publishes `gpt.oauth.all_sessions_revoked` event

    6. `listSessions(clerkUserId: string) -> GptSession[]`:
       - Returns all active sessions for user with created_at, last_active, scopes, refresh token expiry

    7. `validateAccessToken(token: string) -> { clerkUserId, sessionId, scopes }`:
       - Strips `gpt_at_` prefix
       - Verifies JWT signature with ES256 public key (derived from private key)
       - Validates claims: iss, aud, exp
       - Returns extracted claims
       - Does NOT check session status (15-min revocation lag acceptable per CONTEXT.md)

    8. `hasExistingConsent(clerkUserId: string, requestedScopes: string[]) -> boolean`:
       - Checks if user has an active session whose granted_scopes is a superset of requestedScopes
       - Used by consent page to determine if consent can be skipped

    **Dependencies to add to package.json:**
    - `jose` library for ES256 JWT signing/verification (NOT jsonwebtoken -- jose is ESM-compatible and supports ES256 natively)
    - `vitest` as devDependency for testing

    **Test behavior (oauth-service.test.ts):**
    Use vitest with mocked Supabase client. Test cases:
    - authorize: generates code, validates scopes, enforces session limit
    - exchangeCode: validates PKCE, creates session, returns JWT + refresh token
    - refresh: rotates token, detects replay and revokes all sessions
    - revoke: deletes session, revokes refresh token
    - validateAccessToken: verifies ES256 JWT, rejects expired/invalid tokens
    - hasExistingConsent: returns true when superset scopes exist
  </behavior>
  <implementation>
    1. Create types.ts with scope constants, param types, and OAuthError class
    2. Create oauth-service.ts with OAuthService class
    3. Use `jose` library (import { SignJWT, jwtVerify, importPKCS8, exportSPKI, importSPKI } from 'jose') for ES256 operations
    4. Decode ecPrivateKeyBase64 from GptConfig to get PEM string, then import as CryptoKey
    5. For token hashing: use Node.js crypto.createHash('sha256')
    6. For random token generation: use Node.js crypto.randomBytes
    7. For PKCE verification: SHA-256 hash of verifier, base64url-encoded, compared to stored challenge
    8. Add `jose` to dependencies, `vitest` to devDependencies in package.json
    9. Add `"test": "vitest run"` script to package.json
  </implementation>
</feature>

<verification>
1. `pnpm --filter @splits-network/gpt-service test` passes all test cases
2. OAuthService class exports all 8 methods
3. Types file exports GPT_SCOPES, READ_SCOPES, GptScope, all param/response types
4. JWT tokens are prefixed with `gpt_at_`, refresh tokens with `gpt_rt_`
5. Replay detection test: replaying rotated token triggers revocation of ALL user sessions
</verification>

<success_criteria>
All OAuth2 token lifecycle operations are implemented and tested. Authorization code flow with PKCE works end-to-end in tests. JWT access tokens are signed with ES256 and contain correct claims. Refresh token rotation with replay detection is verified.
</success_criteria>

<output>
After completion, create `.planning/phases/12-oauth2-provider/12-02-SUMMARY.md`
</output>
