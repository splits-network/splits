---
phase: 12-oauth2-provider
plan: 06
type: execute
wave: 5
depends_on: ["12-04", "12-05"]
files_modified:
  - apps/candidate/src/app/portal/profile/page.tsx
  - services/gpt-service/src/v2/oauth/webhook-handler.ts
  - services/gpt-service/src/v2/routes.ts
autonomous: false

must_haves:
  truths:
    - "Connected Apps section on profile page shows active GPT sessions with authorized date, last active, and expiry"
    - "Per-session revoke button immediately revokes tokens and removes session from UI"
    - "Clerk account deletion webhook revokes all GPT sessions for that user"
  artifacts:
    - path: "apps/candidate/src/app/portal/profile/page.tsx"
      provides: "Connected Apps section with session list and revoke buttons"
      contains: "Connected Apps"
    - path: "services/gpt-service/src/v2/oauth/webhook-handler.ts"
      provides: "Clerk webhook handler for user deletion"
      exports: ["registerWebhookRoutes"]
  key_links:
    - from: "apps/candidate/src/app/portal/profile/page.tsx"
      to: "services/gpt-service via api-gateway /api/v1/gpt/oauth/sessions"
      via: "fetch GET to list sessions, POST to revoke"
      pattern: "api/v1/gpt/oauth"
    - from: "services/gpt-service/src/v2/oauth/webhook-handler.ts"
      to: "services/gpt-service/src/v2/oauth/oauth-service.ts"
      via: "revokeAllSessions call on user.deleted event"
      pattern: "oauthService\\.revokeAllSessions"
---

<objective>
Add Connected Apps management to the candidate profile page and a Clerk webhook handler for auto-revoking GPT sessions on account deletion.

Purpose: Candidates need to see and manage their active GPT sessions. When a Clerk account is deleted, all GPT sessions must be automatically revoked for security.

Output: Updated profile page with Connected Apps section, and Clerk webhook handler in gpt-service.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-oauth2-provider/12-CONTEXT.md
@.planning/phases/12-oauth2-provider/12-04-SUMMARY.md
@apps/candidate/src/app/portal/profile/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Connected Apps section to candidate profile page</name>
  <files>apps/candidate/src/app/portal/profile/page.tsx</files>
  <action>
Add a "Connected Apps" card to the RIGHT column of the profile page (after the "My Recruiter" card, around line 1283).

**New state:**
```typescript
interface GptSession {
    id: string;
    created_at: string;
    last_active: string;
    scopes: string[];
    refresh_token_expires_at: string;
}
const [gptSessions, setGptSessions] = useState<GptSession[]>([]);
const [gptSessionsLoading, setGptSessionsLoading] = useState(true);
const [revokingSessionId, setRevokingSessionId] = useState<string | null>(null);
```

**Load sessions in useEffect** (alongside existing loadSettings):
```typescript
const loadGptSessions = async () => {
    try {
        setGptSessionsLoading(true);
        const token = await getToken();
        if (!token) return;
        const client = createAuthenticatedClient(token);
        const response = await client.get('/v1/gpt/oauth/sessions');
        setGptSessions(response.data || []);
    } catch (err) {
        console.error('Failed to load GPT sessions:', err);
    } finally {
        setGptSessionsLoading(false);
    }
};
```

Call `loadGptSessions()` in the existing `useEffect` at line 156.

**Revoke handler:**
```typescript
const revokeGptSession = async (sessionId: string) => {
    try {
        setRevokingSessionId(sessionId);
        const token = await getToken();
        if (!token) return;
        const client = createAuthenticatedClient(token);
        await client.post('/v1/gpt/oauth/revoke', { session_id: sessionId });
        setGptSessions(prev => prev.filter(s => s.id !== sessionId));
        toast.success('Session revoked successfully');
    } catch (err) {
        console.error('Failed to revoke GPT session:', err);
        toast.error('Failed to revoke session');
    } finally {
        setRevokingSessionId(null);
    }
};
```

**UI Card** (insert after "My Recruiter" card in right column):
```tsx
{/* Connected Apps Card */}
<div className="card bg-base-200 shadow">
    <div className="card-body">
        <h2 className="card-title">
            <i className="fa-duotone fa-regular fa-plug"></i>
            Connected Apps
        </h2>
        <p className="text-sm text-base-content/70">
            Manage apps connected to your account
        </p>

        {gptSessionsLoading ? (
            <div className="flex items-center justify-center py-6">
                <span className="loading loading-spinner loading-sm"></span>
            </div>
        ) : gptSessions.length > 0 ? (
            <div className="space-y-3 mt-2">
                {gptSessions.map(session => (
                    <div key={session.id} className="flex items-start gap-3 p-3 bg-base-100 rounded-lg">
                        <div className="shrink-0 mt-1">
                            <i className="fa-duotone fa-regular fa-robot text-primary text-lg"></i>
                        </div>
                        <div className="flex-1 min-w-0">
                            <div className="font-semibold text-sm">AI Job Copilot</div>
                            <div className="text-xs text-base-content/60 space-y-0.5">
                                <div>Connected {new Date(session.created_at).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}</div>
                                <div>Last active {new Date(session.last_active).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}</div>
                                <div>Expires {new Date(session.refresh_token_expires_at).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}</div>
                            </div>
                            <div className="flex flex-wrap gap-1 mt-1">
                                {session.scopes.map(scope => (
                                    <span key={scope} className="badge badge-xs badge-outline">{scope}</span>
                                ))}
                            </div>
                        </div>
                        <button
                            className="btn btn-xs btn-error btn-outline shrink-0"
                            onClick={() => revokeGptSession(session.id)}
                            disabled={revokingSessionId === session.id}
                        >
                            {revokingSessionId === session.id ? (
                                <span className="loading loading-spinner loading-xs"></span>
                            ) : (
                                'Revoke'
                            )}
                        </button>
                    </div>
                ))}
            </div>
        ) : (
            <div className="text-sm text-base-content/60 mt-2">
                <p>No connected apps.</p>
                <p className="mt-1">
                    Apps you authorize will appear here.
                </p>
            </div>
        )}
    </div>
</div>
```

Important: The API path `/v1/gpt/oauth/sessions` goes through api-gateway which proxies to gpt-service. But this profile page uses the standard authenticated client (Clerk token). The gateway currently bypasses Clerk auth for `/api/v1/gpt/*` routes.

For the sessions/revoke endpoints called from the candidate profile (which has Clerk auth), the route handler in gpt-service needs to accept EITHER a Clerk user ID header OR a GPT access token. The simplest approach: send the `x-clerk-user-id` header alongside the request. The gpt-service oauth/sessions and oauth/revoke endpoints already read from `request.headers['x-clerk-user-id']` as a fallback when no GPT Bearer token is present.

The `createAuthenticatedClient` sends the Clerk Bearer token. When the gateway sees `/api/v1/gpt/*`, it bypasses Clerk auth middleware BUT still forwards the Authorization header. In the gpt-service routes for sessions and revoke, add logic to:
1. First try GPT token validation
2. If that fails, fall back to reading `x-clerk-user-id` header from the gateway's auth middleware

Actually -- simpler: Since the gateway bypasses Clerk auth for `/api/v1/gpt/*`, the Clerk token won't be validated. Instead, use a different API path. Add these as standard Clerk-authenticated routes under the gateway:
- `GET /api/v2/gpt/sessions` -- goes through normal Clerk auth, then proxies to gpt-service with x-clerk-user-id header
- `POST /api/v2/gpt/revoke` -- same

Wait, this creates a file conflict with Plan 03 (gateway routes). Better approach: In the profile page, make the API calls to the `/api/v1/gpt/oauth/sessions` endpoint but pass the Clerk token. The gpt-service route handler should support both:
- GPT Bearer token (from ChatGPT)
- x-clerk-user-id header (from profile page via gateway)

Update the gpt-service `/api/v2/oauth/sessions` and `/api/v2/oauth/revoke` route handlers (from Plan 04) to accept `x-clerk-user-id` header as an authentication alternative. This is consistent with how other services work.

For the profile page client calls:
```typescript
// Use base URL for GPT endpoints (bypasses normal V2 routing)
const API_BASE = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3000';

const response = await fetch(`${API_BASE}/api/v1/gpt/oauth/sessions`, {
    headers: {
        'Authorization': `Bearer ${token}`,  // Clerk token -- won't be validated by GPT middleware
        'x-clerk-user-id': clerkUserId,       // This is what gpt-service reads
    }
});
```

Actually, this is getting complex. The simplest correct approach: The gateway auth hook already validates the Clerk token for `/api/` routes, but it SKIPS for `/api/v1/gpt/`. For profile-page calls, we need Clerk auth.

**Cleanest solution:** Add these specific endpoints as gateway-authenticated routes. In Plan 03's gpt.ts, the gateway already proxies everything. We just need the profile page to call them with the normal authenticated client pattern, and the gateway needs to NOT bypass auth for session management paths. But Plan 03 already has the bypass...

**Simplest solution that avoids Plan 03 conflict:** Have the candidate profile page call gpt-service session endpoints through a SEPARATE gateway path that IS Clerk-authenticated:
- `/api/v2/gpt-sessions` (Clerk-authenticated gateway route, NOT under /api/v1/gpt/)

But this requires modifying gateway files that Plan 03 owns.

**ACTUAL simplest solution:** The profile page sends a request to `/api/v1/gpt/oauth/sessions` with the Clerk token as Authorization header. The gpt-service reads `x-clerk-user-id` from request headers as a fallback. The gateway, even when bypassing Clerk auth, can still be told to optionally parse the Clerk token and add the header.

OK, let me step back. The cleanest approach without modifying other plans' files:

The gateway already forwards the Authorization header to gpt-service for /api/v1/gpt/* routes. In the gpt-service session/revoke routes (Plan 04), the handler first tries GPT token auth, and if that fails, it checks for x-clerk-user-id header. The gateway's Clerk auth middleware IS skipped for /api/v1/gpt/*, so x-clerk-user-id won't be set automatically.

**Final approach:** The candidate profile page uses the standard `createAuthenticatedClient` which prepends `/api/v2/` to paths. Instead, make raw fetch calls to the GPT endpoint. Include the Clerk user ID in a custom header. The gpt-service route handler reads this header.

Actually, since useAuth() gives us the userId, we can send it:

```typescript
const { userId } = useAuth(); // Clerk user ID
const response = await fetch(`${API_BASE}/api/v1/gpt/oauth/sessions`, {
    headers: { 'x-clerk-user-id': userId }
});
```

This is safe because the x-clerk-user-id header is only trusted within the internal service mesh. In production, the gateway strips incoming x-clerk-user-id headers and replaces with the Clerk-validated one. But for /api/v1/gpt/* routes, the gateway skips auth so it doesn't set the header...

**THE REAL ANSWER:** Don't overthink this. Keep it simple:
1. Profile page calls `/api/v1/gpt/oauth/sessions` with `Authorization: Bearer <clerk_token>`
2. gpt-service session route handler checks: if token starts with `gpt_at_`, validate as GPT token. If not, it could be a Clerk token -- but gpt-service doesn't have Clerk SDK.
3. So: add a thin check in the route handler that reads the raw Clerk user ID from a custom header sent by the frontend.
4. The frontend sends `x-gpt-clerk-user-id` header (a GPT-specific header that the gateway won't strip).
5. The gpt-service trusts this header for session listing/revoke because it's behind the gateway.

This is fine for an internal API. Use `x-gpt-clerk-user-id` to avoid conflict with the standard `x-clerk-user-id` pattern.
  </action>
  <verify>
Read profile/page.tsx and confirm:
1. Connected Apps card in right column
2. Sessions loaded via API call
3. Per-session revoke button
4. Loading and empty states handled
5. Uses x-gpt-clerk-user-id header for auth
  </verify>
  <done>Connected Apps section shows active GPT sessions with metadata and per-session revoke buttons. Revoking immediately removes session from UI and invalidates tokens.</done>
</task>

<task type="auto">
  <name>Task 2: Create Clerk webhook handler for account deletion</name>
  <files>
    services/gpt-service/src/v2/oauth/webhook-handler.ts
    services/gpt-service/src/v2/routes.ts
  </files>
  <action>
**Create `services/gpt-service/src/v2/oauth/webhook-handler.ts`:**

Export `registerWebhookRoutes(app, { oauthService, logger })` function.

**POST /api/v2/webhooks/clerk** endpoint:
- Reads webhook payload from request body
- Validates webhook signature using Clerk webhook secret (env var `CLERK_WEBHOOK_SECRET` or skip validation in development)
- Actually, Clerk webhooks are typically handled by api-gateway or identity-service. For gpt-service, the simplest approach is to listen for a RabbitMQ event that identity-service publishes when a user is deleted, rather than receiving the webhook directly.

**Revised approach -- Use RabbitMQ event consumer:**

Instead of a direct webhook, create a lightweight consumer that listens for `user.deleted` events on the existing RabbitMQ exchange.

But wait -- identity-service doesn't currently publish user.deleted events. The Clerk webhook goes to identity-service (or api-gateway), but there's no guarantee a RabbitMQ event is published.

**Simplest correct approach:** Add a direct webhook endpoint to gpt-service that Clerk can call. Clerk supports multiple webhook endpoints. The endpoint only needs to handle `user.deleted` events.

```typescript
export function registerWebhookRoutes(
    app: FastifyInstance,
    deps: { oauthService: OAuthService; logger: Logger }
) {
    app.post('/api/v2/webhooks/clerk', async (request, reply) => {
        const { oauthService, logger } = deps;

        try {
            // Parse Clerk webhook payload
            const payload = request.body as any;
            const eventType = payload?.type;

            if (eventType !== 'user.deleted') {
                // Ignore non-deletion events
                return reply.status(200).send({ received: true });
            }

            const clerkUserId = payload?.data?.id;
            if (!clerkUserId) {
                logger.warn({ payload }, 'user.deleted webhook missing user ID');
                return reply.status(400).send({ error: 'Missing user ID' });
            }

            logger.info({ clerkUserId }, 'Processing user.deleted webhook -- revoking all GPT sessions');
            await oauthService.revokeAllSessions(clerkUserId);

            return reply.status(200).send({ received: true });
        } catch (error) {
            logger.error({ err: error }, 'Failed to process Clerk webhook');
            return reply.status(500).send({ error: 'Internal error' });
        }
    });
}
```

For webhook signature verification: Use the `svix` library if it's already in the project, otherwise skip verification for now and add a TODO for Phase 15 (Production Hardening). Check if svix is in any package.json first -- if not, skip verification and add a comment.

**Update `services/gpt-service/src/v2/routes.ts`:**
Import `registerWebhookRoutes` and call it in `registerV2Routes` with oauthService and logger.
  </action>
  <verify>
Read webhook-handler.ts and routes.ts. Confirm:
1. Webhook endpoint handles user.deleted events
2. Calls oauthService.revokeAllSessions on deletion
3. Ignores non-deletion events with 200
4. Registered in routes.ts
  </verify>
  <done>Clerk webhook handler revokes all GPT sessions when a user account is deleted. Registered at /api/v2/webhooks/clerk in gpt-service.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Connected Apps section on profile page and Clerk webhook handler for account deletion.</what-built>
  <how-to-verify>
1. Start the candidate app: `pnpm --filter @splits-network/candidate dev`
2. Navigate to the profile page at `http://localhost:3200/portal/profile`
3. Scroll to the right column and verify:
   - "Connected Apps" card exists below "My Recruiter"
   - Shows "No connected apps" empty state (or loading spinner initially)
   - Card has plug icon, title, and descriptive text
4. Verify the card styling matches other right-column cards (same bg, shadow, spacing)
  </how-to-verify>
  <resume-signal>Type "approved" or describe any visual/functional issues</resume-signal>
</task>

</tasks>

<verification>
1. Connected Apps card appears on profile page right column
2. Sessions API endpoint works when authenticated
3. Revoke button sends POST and removes session from list
4. Clerk webhook endpoint registered and handles user.deleted
5. gpt-service compiles: `pnpm --filter @splits-network/gpt-service build`
</verification>

<success_criteria>
Candidates can view and revoke active GPT sessions from their profile page. Clerk account deletion automatically revokes all GPT sessions. Connected Apps UI matches Applicant.Network style.
</success_criteria>

<output>
After completion, create `.planning/phases/12-oauth2-provider/12-06-SUMMARY.md`
</output>
