---
phase: 09-api
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - services/ats-service/src/v2/jobs/types.ts
  - services/ats-service/src/v2/jobs/repository.ts
  - services/ats-service/src/v2/jobs/service.ts
autonomous: true

must_haves:
  truths:
    - "POST /v2/jobs with commute_types and job_level in body persists both fields to the database"
    - "PATCH /v2/jobs/:id with commute_types and job_level updates those fields"
    - "GET /v2/jobs and GET /v2/jobs/:id return commute_types and job_level in the response"
    - "GET /v2/jobs?commute_type=remote returns only jobs whose commute_types array contains remote"
    - "GET /v2/jobs?job_level=senior returns only jobs with job_level=senior"
  artifacts:
    - path: "services/ats-service/src/v2/jobs/types.ts"
      provides: "commute_type and job_level filter params in JobFilters; commute_types and job_level in JobUpdate"
      contains: "commute_type"
    - path: "services/ats-service/src/v2/jobs/repository.ts"
      provides: "Postgres array overlap filtering for commute_type and eq filtering for job_level"
      contains: "commute_type"
    - path: "services/ats-service/src/v2/jobs/service.ts"
      provides: "Validation of commute_types values and job_level value on create and update"
      contains: "commute_types"
  key_links:
    - from: "services/ats-service/src/v2/jobs/types.ts"
      to: "services/ats-service/src/v2/jobs/repository.ts"
      via: "JobFilters import used in findJobs params"
      pattern: "filters\\.commute_type"
    - from: "services/ats-service/src/v2/jobs/service.ts"
      to: "services/ats-service/src/v2/jobs/repository.ts"
      via: "validated data passed to createJob/updateJob"
      pattern: "commute_types|job_level"
---

<objective>
Wire commute_types and job_level through the ATS service CRUD and filtering layer.

Purpose: The database columns and TypeScript types exist (Phase 8), but the ATS service does not yet filter by, validate, or explicitly handle these fields. This plan makes the API fully functional for commute types and job levels.

Output: Updated types.ts, repository.ts, and service.ts so that jobs can be created, updated, read, and filtered by commute_types (array overlap) and job_level (exact match).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-schema-and-types/08-01-SUMMARY.md
@services/ats-service/src/v2/jobs/types.ts
@services/ats-service/src/v2/jobs/repository.ts
@services/ats-service/src/v2/jobs/service.ts
@services/ats-service/src/v2/jobs/routes.ts
@packages/shared-types/src/models.ts
@packages/shared-types/src/dtos.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add filter params to types.ts and filtering logic to repository.ts</name>
  <files>
    services/ats-service/src/v2/jobs/types.ts
    services/ats-service/src/v2/jobs/repository.ts
  </files>
  <action>
    **types.ts changes:**

    1. Add `commute_type?: string | string[]` to the `JobFilters` interface. This is a query param that can be a single value or repeated values (e.g., `?commute_type=remote&commute_type=hybrid_1`). It represents the filter REQUEST, not the column shape.

    2. Add `job_level?: string` to the `JobFilters` interface. Single-select filter for exact match.

    3. Add `commute_types?: string[]` and `job_level?: string` as explicit properties on the `JobUpdate` interface (alongside the existing fields). Keep the `[key: string]: any` index signature as-is for backward compatibility -- just add the explicit typed fields for clarity.

    **repository.ts changes:**

    In the `findJobs` method, after the existing filter block that handles `employment_type` (around line 155), add two new filter blocks:

    1. **commute_type filter** -- If `filters.commute_type` is present, normalize it to an array (if string, wrap in array). Then use Supabase's `.overlaps()` method on the `commute_types` column:
       ```typescript
       if (filters.commute_type) {
           const types = Array.isArray(filters.commute_type)
               ? filters.commute_type
               : [filters.commute_type];
           query = query.overlaps('commute_types', types);
       }
       ```
       The `.overlaps()` method maps to PostgreSQL's `&&` operator, which returns true if the arrays share ANY element. This is the "any match" behavior required by API-04.

    2. **job_level filter** -- If `filters.job_level` is present, use `.eq()`:
       ```typescript
       if (filters.job_level) {
           query = query.eq('job_level', filters.job_level);
       }
       ```

    IMPORTANT: The `filters` variable in repository.ts comes from parsing `params.filters` (JSON string from query params). But `commute_type` and `job_level` should also work as top-level query params (like `status`, `location`, `employment_type`). Check both `filters.commute_type` and `params.commute_type` -- use whichever is present, preferring the nested `filters` version. Follow the same pattern as `companyIdFilter` on line 158 which checks both `filters.company_id` and `params.company_id`.

    No changes needed to `createJob`, `updateJob`, `findJob`, or `deleteJob` -- they already use `*` select and spread operator, so commute_types and job_level flow through automatically.
  </action>
  <verify>
    Run `pnpm --filter @splits-network/ats-service build` and confirm zero TypeScript errors.
  </verify>
  <done>
    JobFilters has commute_type and job_level fields. JobUpdate has explicit commute_types and job_level fields. Repository applies .overlaps() for commute_type and .eq() for job_level in findJobs. Build passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add validation in service.ts for commute_types and job_level on create and update</name>
  <files>
    services/ats-service/src/v2/jobs/service.ts
  </files>
  <action>
    Add validation for the new fields in both `createJob` and `updateJob` methods.

    **Define valid values as constants at the top of the file (after imports):**
    ```typescript
    const VALID_COMMUTE_TYPES = ['remote', 'hybrid_1', 'hybrid_2', 'hybrid_3', 'hybrid_4', 'in_office'];
    const VALID_JOB_LEVELS = ['entry', 'mid', 'senior', 'lead', 'manager', 'director', 'vp', 'c_suite'];
    ```

    **In `createJob` method**, after the existing `company_id` validation (line ~69), add:

    1. If `data.commute_types` is provided, validate it is an array and every element is in `VALID_COMMUTE_TYPES`. Throw descriptive error if invalid:
       ```typescript
       if (data.commute_types) {
           if (!Array.isArray(data.commute_types)) {
               throw new Error('commute_types must be an array');
           }
           const invalid = data.commute_types.filter((t: string) => !VALID_COMMUTE_TYPES.includes(t));
           if (invalid.length > 0) {
               throw new Error(`Invalid commute_types: ${invalid.join(', ')}. Valid values: ${VALID_COMMUTE_TYPES.join(', ')}`);
           }
       }
       ```

    2. If `data.job_level` is provided, validate it is in `VALID_JOB_LEVELS`:
       ```typescript
       if (data.job_level && !VALID_JOB_LEVELS.includes(data.job_level)) {
           throw new Error(`Invalid job_level: ${data.job_level}. Valid values: ${VALID_JOB_LEVELS.join(', ')}`);
       }
       ```

    **In `updateJob` method**, after the existing salary validation block (around line 151), add the same validation for `updates.commute_types` and `updates.job_level` using the same patterns above. This ensures updates also validate.

    Do NOT import CommuteType/JobLevel from shared-types -- keep the validation self-contained with the const arrays to avoid coupling the service to shared-types union types (the service uses `any` types throughout).
  </action>
  <verify>
    Run `pnpm --filter @splits-network/ats-service build` and confirm zero TypeScript errors. Then run `pnpm --filter @splits-network/ats-service test` if tests exist.
  </verify>
  <done>
    createJob validates commute_types array values and job_level value against allowed sets. updateJob validates the same. Invalid values produce clear error messages. Build passes with zero errors.
  </done>
</task>

</tasks>

<verification>
1. `pnpm --filter @splits-network/ats-service build` succeeds with zero errors
2. types.ts contains `commute_type` in JobFilters and `commute_types` in JobUpdate
3. repository.ts contains `.overlaps('commute_types'` call in findJobs
4. repository.ts contains `.eq('job_level'` call in findJobs
5. service.ts contains `VALID_COMMUTE_TYPES` and `VALID_JOB_LEVELS` arrays
6. service.ts validates commute_types in both createJob and updateJob
7. service.ts validates job_level in both createJob and updateJob
</verification>

<success_criteria>
- ATS service builds cleanly with the new filter and validation logic
- commute_type filter uses Supabase .overlaps() for array any-match semantics
- job_level filter uses Supabase .eq() for exact match semantics
- Both fields validated against allowed value sets on create and update
- No changes needed to routes.ts or api-gateway (query params and body already flow through)
</success_criteria>

<output>
After completion, create `.planning/phases/09-api/09-01-SUMMARY.md`
</output>
