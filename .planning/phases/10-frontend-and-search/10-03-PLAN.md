---
phase: 10-frontend-and-search
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260218000001_search_index_add_commute_and_level.sql
autonomous: true

must_haves:
  truths:
    - "Search index metadata for jobs includes commute_types and job_level"
    - "Search context text for jobs includes commute type labels and job level label so full-text search matches"
    - "Existing job search_index entries are backfilled with the new metadata"
  artifacts:
    - path: "supabase/migrations/20260218000001_search_index_add_commute_and_level.sql"
      provides: "Updated sync_job_to_search_index and cascade functions, plus backfill"
      contains: "commute_types"
  key_links:
    - from: "sync_job_to_search_index()"
      to: "search.search_index metadata"
      via: "jsonb_build_object includes commute_types and job_level"
      pattern: "commute_types"
    - from: "cascade_company_to_job_search_index()"
      to: "search.search_index metadata"
      via: "jsonb_build_object includes commute_types and job_level"
      pattern: "commute_types"
---

<objective>
Update the search index trigger to include commute_types and job_level in job metadata and context.

Purpose: Jobs should appear in search results when users search by commute type or job level terms (SRCH-01).
Output: SQL migration that updates the sync function, cascade function, and backfills existing entries.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@supabase/migrations/20260213000003_search_index_triggers_core.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create migration to update job search index with commute_types and job_level</name>
  <files>
    supabase/migrations/20260218000001_search_index_add_commute_and_level.sql
  </files>
  <action>
    Create SQL migration with three sections:

    **1. Replace sync_job_to_search_index() function:**

    Use `CREATE OR REPLACE FUNCTION` to update the existing function. Changes from the original:

    a) In the `context` field (CONCAT_WS), append commute_types array values and job_level:
       ```sql
       CONCAT_WS(' ', NEW.title, NEW.description, NEW.recruiter_description, NEW.candidate_description, NEW.company_name, NEW.company_industry, NEW.company_headquarters_location, NEW.location, NEW.employment_type, NEW.department, NEW.status, array_to_string(NEW.commute_types, ' '), NEW.job_level)
       ```

    b) In the `metadata` jsonb_build_object, add two new keys:
       ```sql
       jsonb_build_object(
           'company_name', NEW.company_name,
           'location', NEW.location,
           'employment_type', NEW.employment_type,
           'department', NEW.department,
           'status', NEW.status,
           'company_industry', NEW.company_industry,
           'commute_types', COALESCE(to_jsonb(NEW.commute_types), '[]'::jsonb),
           'job_level', NEW.job_level
       )
       ```
       Note: `to_jsonb(TEXT[])` produces a JSON array. Use COALESCE to default NULL to empty array.

    Keep everything else identical (search_vector uses NEW.search_vector, organization_id uses NEW.company_id, ON CONFLICT DO UPDATE same structure).

    **2. Replace cascade_company_to_job_search_index() function:**

    Same `CREATE OR REPLACE FUNCTION` approach. In the metadata update:
    ```sql
    metadata = jsonb_build_object(
        'company_name', j.company_name,
        'location', j.location,
        'employment_type', j.employment_type,
        'department', j.department,
        'status', j.status,
        'company_industry', j.company_industry,
        'commute_types', COALESCE(to_jsonb(j.commute_types), '[]'::jsonb),
        'job_level', j.job_level
    )
    ```

    **3. Backfill existing job entries in search_index:**

    Run an UPDATE to refresh metadata and context for all existing job entries:
    ```sql
    UPDATE search.search_index si
    SET
        context = CONCAT_WS(' ', j.title, j.description, j.recruiter_description, j.candidate_description, j.company_name, j.company_industry, j.company_headquarters_location, j.location, j.employment_type, j.department, j.status, array_to_string(j.commute_types, ' '), j.job_level),
        metadata = jsonb_build_object(
            'company_name', j.company_name,
            'location', j.location,
            'employment_type', j.employment_type,
            'department', j.department,
            'status', j.status,
            'company_industry', j.company_industry,
            'commute_types', COALESCE(to_jsonb(j.commute_types), '[]'::jsonb),
            'job_level', j.job_level
        ),
        updated_at = now()
    FROM public.jobs j
    WHERE si.entity_type = 'job'
      AND si.entity_id = j.id;
    ```

    No need to re-create triggers -- `CREATE OR REPLACE FUNCTION` updates the function that existing triggers already reference.

    Add verification queries as a comment block at the end (similar to the original migration):
    ```sql
    /*
    VERIFICATION QUERIES:

    -- Check metadata now includes commute_types and job_level
    SELECT entity_id, metadata->>'job_level' as level, metadata->'commute_types' as commute
    FROM search.search_index
    WHERE entity_type = 'job'
    LIMIT 5;

    -- Test search for "remote" returns jobs with remote commute type
    SELECT entity_id, title, metadata->'commute_types' as commute
    FROM search.search_index
    WHERE entity_type = 'job'
      AND context ILIKE '%remote%';
    */
    ```
  </action>
  <verify>Verify the SQL file exists and contains: (1) CREATE OR REPLACE FUNCTION for sync_job_to_search_index, (2) CREATE OR REPLACE FUNCTION for cascade_company_to_job_search_index, (3) UPDATE statement for backfill, (4) commute_types appears in all three sections.</verify>
  <done>Migration file creates updated trigger functions that include commute_types and job_level in search index metadata and context text. Backfill updates all existing job entries. User must apply this migration to their Supabase instance.</done>
</task>

</tasks>

<verification>
- Migration file exists at `supabase/migrations/20260218000001_search_index_add_commute_and_level.sql`
- File contains CREATE OR REPLACE for both sync and cascade functions
- Both functions include commute_types and job_level in metadata jsonb
- Backfill UPDATE statement refreshes all existing job search_index entries
- No triggers need to be recreated (functions are replaced in-place)
</verification>

<success_criteria>
- Search index for jobs includes commute_types array and job_level in metadata
- Context text includes commute type values and job level for full-text search
- Existing entries are backfilled
- Migration is idempotent (can be re-run safely due to CREATE OR REPLACE and UPDATE)
</success_criteria>

<output>
After completion, create `.planning/phases/10-frontend-and-search/10-03-SUMMARY.md`
</output>
