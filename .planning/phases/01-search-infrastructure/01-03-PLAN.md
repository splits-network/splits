---
phase: 01-search-infrastructure
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - supabase/migrations/YYYYMMDD000003_search_index_triggers_relational.sql
autonomous: true

must_haves:
  truths:
    - "Inserting/updating a recruiter immediately creates/updates a row in search.search_index with recruiter name from users table"
    - "Inserting/updating an application immediately creates/updates a row in search.search_index with candidate name and job title"
    - "Inserting/updating a placement immediately creates/updates a row in search.search_index with candidate, job, company, and recruiter info"
    - "Inserting/updating a recruiter_candidate immediately creates/updates a row in search.search_index"
    - "Query against search_index returns ranked results across ALL 7 entity types with ts_rank scoring"
  artifacts:
    - path: "supabase/migrations/YYYYMMDD000003_search_index_triggers_relational.sql"
      provides: "Trigger functions + triggers for recruiters, applications, placements, recruiter_candidates syncing to search.search_index"
      contains: "sync_recruiter_to_search_index"
  key_links:
    - from: "public.recruiters trigger"
      to: "search.search_index"
      via: "sync_recruiter_to_search_index trigger function"
      pattern: "INSERT INTO search.search_index"
    - from: "public.applications trigger"
      to: "search.search_index"
      via: "sync_application_to_search_index trigger function"
      pattern: "INSERT INTO search.search_index"
    - from: "public.placements trigger"
      to: "search.search_index"
      via: "sync_placement_to_search_index trigger function"
      pattern: "INSERT INTO search.search_index"
---

<objective>
Create trigger-based sync from recruiters, applications, placements, and recruiter_candidates tables to search.search_index. These are "relational" entity types that need cross-table JOINs for denormalized data (recruiter name from users, candidate/job from their tables).

Purpose: Completes the search index sync for all 7 entity types, enabling full cross-entity global search.
Output: Migration file with 4 trigger functions, 4+ triggers (including cascade triggers), and backfill statements.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-search-infrastructure/01-01-SUMMARY.md

Key reference for existing patterns:
@supabase/migrations/20240101000000_baseline.sql (lines 262-353 for build_placements_search_vector, build_recruiters_search_vector, and existing cascade triggers)
@docs/search/scalable-search-architecture.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create trigger functions and triggers for recruiters, applications, placements, recruiter_candidates</name>
  <files>supabase/migrations/YYYYMMDD000003_search_index_triggers_relational.sql</files>
  <action>
  Create a new migration file (timestamp after Plan 02's migration, e.g., `20260213000004_search_index_triggers_relational.sql`).

  These entities are more complex because they need data from related tables.

  ---

  **1. RECRUITERS** (entity_type: 'recruiter')

  The recruiters table gets user name/email from the `users` table via `user_id` FK. The existing `build_recruiters_search_vector(p_recruiter_id)` already does this lookup internally. For the search_index sync, we need to do the lookup in the trigger function.

  ```sql
  CREATE OR REPLACE FUNCTION search.sync_recruiter_to_search_index() RETURNS trigger AS $$
  DECLARE
      v_user_name text;
      v_user_email text;
  BEGIN
      -- Lookup user data
      SELECT u.name, u.email
      INTO v_user_name, v_user_email
      FROM public.users u
      WHERE u.id = NEW.user_id;

      INSERT INTO search.search_index (entity_type, entity_id, title, subtitle, context, search_vector, metadata, organization_id, updated_at)
      VALUES (
          'recruiter',
          NEW.id,
          COALESCE(v_user_name, ''),
          CONCAT_WS(' - ', NULLIF(NEW.tagline, ''), NULLIF(NEW.location, '')),
          CONCAT_WS(' ', v_user_name, v_user_email, NEW.bio, NEW.tagline, array_to_string(NEW.industries, ' '), array_to_string(NEW.specialties, ' '), NEW.location, NEW.phone),
          NEW.search_vector,  -- Already computed by the BEFORE trigger update_recruiters_search_vector_trigger
          jsonb_build_object('email', v_user_email, 'location', NEW.location, 'tagline', NEW.tagline, 'industries', NEW.industries, 'specialties', NEW.specialties, 'status', NEW.status, 'marketplace_enabled', NEW.marketplace_enabled),
          NULL,  -- Recruiters are not org-scoped
          now()
      )
      ON CONFLICT (entity_type, entity_id)
      DO UPDATE SET
          title = EXCLUDED.title,
          subtitle = EXCLUDED.subtitle,
          context = EXCLUDED.context,
          search_vector = EXCLUDED.search_vector,
          metadata = EXCLUDED.metadata,
          updated_at = EXCLUDED.updated_at;
      RETURN NEW;
  END;
  $$ LANGUAGE plpgsql;
  ```

  Trigger: AFTER INSERT OR UPDATE on public.recruiters.

  Also need a cascade: when user name/email changes, update recruiter entries in search_index:
  ```sql
  CREATE OR REPLACE FUNCTION search.cascade_user_to_recruiter_search_index() RETURNS trigger AS $$
  BEGIN
      UPDATE search.search_index si
      SET
          title = NEW.name,
          context = CONCAT_WS(' ', NEW.name, NEW.email, r.bio, r.tagline, array_to_string(r.industries, ' '), array_to_string(r.specialties, ' '), r.location, r.phone),
          search_vector = r.search_vector,  -- Already updated by sync_recruiter_user_search_vector trigger
          metadata = jsonb_set(
              jsonb_set(si.metadata, '{email}', to_jsonb(NEW.email)),
              '{name}', to_jsonb(NEW.name)
          ),
          updated_at = now()
      FROM public.recruiters r
      WHERE si.entity_type = 'recruiter'
        AND si.entity_id = r.id
        AND r.user_id = NEW.id;
      RETURN NEW;
  END;
  $$ LANGUAGE plpgsql;

  CREATE OR REPLACE TRIGGER cascade_user_to_recruiter_search_index
  AFTER UPDATE OF name, email ON public.users
  FOR EACH ROW
  EXECUTE FUNCTION search.cascade_user_to_recruiter_search_index();
  ```

  ---

  **2. APPLICATIONS** (entity_type: 'application')

  Applications table already has denormalized columns: candidate_name, candidate_email, job_title, company_name (maintained by existing sync triggers).

  ```sql
  CREATE OR REPLACE FUNCTION search.sync_application_to_search_index() RETURNS trigger AS $$
  BEGIN
      INSERT INTO search.search_index (entity_type, entity_id, title, subtitle, context, search_vector, metadata, organization_id, updated_at)
      VALUES (
          'application',
          NEW.id,
          COALESCE(NEW.candidate_name, '') || ' - ' || COALESCE(NEW.job_title, ''),
          CONCAT_WS(' at ', NULLIF(NEW.job_title, ''), NULLIF(NEW.company_name, '')),
          CONCAT_WS(' ', NEW.candidate_name, NEW.candidate_email, NEW.job_title, NEW.company_name, NEW.notes, NEW.stage, NEW.recruiter_notes, NEW.candidate_notes),
          NEW.search_vector,  -- Already computed by update_applications_search_vector trigger
          jsonb_build_object('candidate_name', NEW.candidate_name, 'candidate_email', NEW.candidate_email, 'job_title', NEW.job_title, 'company_name', NEW.company_name, 'stage', NEW.stage),
          NULL,  -- Organization filtering done at query time via access context
          now()
      )
      ON CONFLICT (entity_type, entity_id)
      DO UPDATE SET
          title = EXCLUDED.title,
          subtitle = EXCLUDED.subtitle,
          context = EXCLUDED.context,
          search_vector = EXCLUDED.search_vector,
          metadata = EXCLUDED.metadata,
          updated_at = EXCLUDED.updated_at;
      RETURN NEW;
  END;
  $$ LANGUAGE plpgsql;
  ```

  Trigger: AFTER INSERT OR UPDATE on public.applications.

  Cascade triggers: When candidate name/email or job title/company changes, the existing application sync triggers update the denormalized fields AND search_vector on the applications table. This will then fire our AFTER trigger above, cascading to search_index automatically. No separate cascade trigger needed.

  ---

  **3. PLACEMENTS** (entity_type: 'placement')

  Placements table already has denormalized columns: candidate_name, candidate_email, job_title, company_name, recruiter_name, recruiter_email (maintained by existing sync triggers).

  ```sql
  CREATE OR REPLACE FUNCTION search.sync_placement_to_search_index() RETURNS trigger AS $$
  BEGIN
      INSERT INTO search.search_index (entity_type, entity_id, title, subtitle, context, search_vector, metadata, organization_id, updated_at)
      VALUES (
          'placement',
          NEW.id,
          COALESCE(NEW.candidate_name, '') || ' - ' || COALESCE(NEW.job_title, ''),
          CONCAT_WS(' at ', NULLIF(NEW.job_title, ''), NULLIF(NEW.company_name, '')),
          CONCAT_WS(' ', NEW.candidate_name, NEW.candidate_email, NEW.job_title, NEW.company_name, NEW.recruiter_name, NEW.recruiter_email, NEW.state, CASE WHEN NEW.salary IS NOT NULL THEN NEW.salary::text ELSE '' END, NEW.failure_reason),
          NEW.search_vector,  -- Already computed by update_placements_search_vector trigger
          jsonb_build_object('candidate_name', NEW.candidate_name, 'job_title', NEW.job_title, 'company_name', NEW.company_name, 'recruiter_name', NEW.recruiter_name, 'state', NEW.state, 'salary', NEW.salary),
          NULL,  -- Organization filtering done at query time
          now()
      )
      ON CONFLICT (entity_type, entity_id)
      DO UPDATE SET
          title = EXCLUDED.title,
          subtitle = EXCLUDED.subtitle,
          context = EXCLUDED.context,
          search_vector = EXCLUDED.search_vector,
          metadata = EXCLUDED.metadata,
          updated_at = EXCLUDED.updated_at;
      RETURN NEW;
  END;
  $$ LANGUAGE plpgsql;
  ```

  Trigger: AFTER INSERT OR UPDATE on public.placements.

  Cascade: Same as applications -- existing sync triggers on candidates/jobs/companies/users already update placements' denormalized fields + search_vector, which fires our AFTER trigger.

  ---

  **4. RECRUITER_CANDIDATES** (entity_type: 'recruiter_candidate')

  Already has denormalized columns: candidate_name, candidate_email, candidate_location.

  ```sql
  CREATE OR REPLACE FUNCTION search.sync_recruiter_candidate_to_search_index() RETURNS trigger AS $$
  DECLARE
      v_recruiter_name text;
  BEGIN
      -- Lookup recruiter name for the title
      SELECT u.name INTO v_recruiter_name
      FROM public.users u
      JOIN public.recruiters r ON r.user_id = u.id
      WHERE r.id = NEW.recruiter_id;

      INSERT INTO search.search_index (entity_type, entity_id, title, subtitle, context, search_vector, metadata, organization_id, updated_at)
      VALUES (
          'recruiter_candidate',
          NEW.id,
          COALESCE(NEW.candidate_name, ''),
          CONCAT_WS(' - Recruiter: ', NULLIF(NEW.candidate_location, ''), v_recruiter_name),
          CONCAT_WS(' ', NEW.candidate_name, NEW.candidate_email, NEW.candidate_location, NEW.status, v_recruiter_name),
          NEW.search_vector,  -- Already computed by update_recruiter_candidate_search_vector trigger
          jsonb_build_object('candidate_name', NEW.candidate_name, 'candidate_email', NEW.candidate_email, 'candidate_location', NEW.candidate_location, 'status', NEW.status, 'recruiter_name', v_recruiter_name, 'recruiter_id', NEW.recruiter_id),
          NULL,
          now()
      )
      ON CONFLICT (entity_type, entity_id)
      DO UPDATE SET
          title = EXCLUDED.title,
          subtitle = EXCLUDED.subtitle,
          context = EXCLUDED.context,
          search_vector = EXCLUDED.search_vector,
          metadata = EXCLUDED.metadata,
          updated_at = EXCLUDED.updated_at;
      RETURN NEW;
  END;
  $$ LANGUAGE plpgsql;
  ```

  Trigger: AFTER INSERT OR UPDATE on public.recruiter_candidates.

  ---

  **Delete triggers** for all 4 entity types (reuse the generic delete function from Plan 02):
  ```sql
  CREATE TRIGGER delete_recruiter_from_search_index
  AFTER DELETE ON public.recruiters FOR EACH ROW
  EXECUTE FUNCTION search.delete_from_search_index('recruiter');

  CREATE TRIGGER delete_application_from_search_index
  AFTER DELETE ON public.applications FOR EACH ROW
  EXECUTE FUNCTION search.delete_from_search_index('application');

  CREATE TRIGGER delete_placement_from_search_index
  AFTER DELETE ON public.placements FOR EACH ROW
  EXECUTE FUNCTION search.delete_from_search_index('placement');

  CREATE TRIGGER delete_recruiter_candidate_from_search_index
  AFTER DELETE ON public.recruiter_candidates FOR EACH ROW
  EXECUTE FUNCTION search.delete_from_search_index('recruiter_candidate');
  ```

  ---

  **Backfill statements** for all 4 entity types at the end. Follow the same INSERT...SELECT...ON CONFLICT pattern. For recruiters and recruiter_candidates, include the user/recruiter name JOINs.

  ---

  **Comprehensive verification queries** (as comments at bottom):
  ```sql
  /*
  -- COMPREHENSIVE VERIFICATION (run after both trigger migrations):

  -- 1. All 7 entity types present
  SELECT entity_type, COUNT(*) as count
  FROM search.search_index
  GROUP BY entity_type
  ORDER BY entity_type;

  -- 2. Cross-entity search test
  SELECT entity_type, title, subtitle,
         ts_rank(search_vector, websearch_to_tsquery('english', 'engineer')) as rank
  FROM search.search_index
  WHERE search_vector @@ websearch_to_tsquery('english', 'engineer')
  ORDER BY rank DESC
  LIMIT 15;

  -- 3. Verify search_vector is populated (no NULLs)
  SELECT entity_type,
         COUNT(*) as total,
         COUNT(search_vector) as with_vector,
         COUNT(*) - COUNT(search_vector) as null_vectors
  FROM search.search_index
  GROUP BY entity_type;

  -- 4. Verify metadata structure per entity type
  SELECT entity_type, jsonb_object_keys(metadata) as key
  FROM search.search_index
  GROUP BY entity_type, jsonb_object_keys(metadata)
  ORDER BY entity_type, key;

  -- 5. Multi-word search across all entities
  SELECT entity_type, title, subtitle,
         ts_rank(search_vector, websearch_to_tsquery('english', 'software engineer')) as rank
  FROM search.search_index
  WHERE search_vector @@ websearch_to_tsquery('english', 'software engineer')
  ORDER BY rank DESC
  LIMIT 10;
  */
  ```
  </action>
  <verify>
  Review the SQL file for syntax correctness. Verify:
  - 4 sync trigger functions exist (recruiter, application, placement, recruiter_candidate)
  - All sync triggers are AFTER INSERT OR UPDATE
  - User cascade trigger exists for recruiter search_index updates
  - 4 delete triggers exist using the shared delete function
  - All 4 backfill statements exist with correct JOINs
  - Comprehensive verification queries are documented
  </verify>
  <done>
  - Migration file exists with trigger functions for recruiters, applications, placements, recruiter_candidates
  - Recruiters trigger looks up user name/email from users table
  - Applications and placements triggers use existing denormalized columns
  - Recruiter_candidates trigger looks up recruiter name
  - User cascade trigger updates recruiter entries when user data changes
  - Delete triggers for all 4 entity types
  - Backfill populates search_index for all 4 entity types
  - INFRA-05 (recruiters), INFRA-06 (applications), INFRA-07 (placements) + recruiter_candidates complete
  </done>
</task>

<task type="auto">
  <name>Task 2: End-to-end verification of complete search_index</name>
  <files>none (verification only)</files>
  <action>
  After the migration file is finalized, perform a final review of the complete Phase 1 deliverables:

  1. Confirm Plan 01's migration creates the search schema + table + indexes
  2. Confirm Plan 02's migration creates triggers for candidates, jobs, companies
  3. Confirm this Plan 03's migration creates triggers for recruiters, applications, placements, recruiter_candidates
  4. Confirm the recruiters repository uses textSearch instead of ILIKE

  Create a checklist summary verifying all 9 INFRA requirements are addressed:
  - INFRA-01: search.search_index table (Plan 01)
  - INFRA-02: Candidates trigger (Plan 02)
  - INFRA-03: Jobs trigger (Plan 02)
  - INFRA-04: Companies trigger (Plan 02)
  - INFRA-05: Recruiters trigger (Plan 03)
  - INFRA-06: Applications trigger (Plan 03)
  - INFRA-07: Placements trigger (Plan 03)
  - INFRA-08: GIN index on search_vector (Plan 01)
  - INFRA-09: Recruiters ILIKE -> tsvector (Plan 01)

  Also verify the 5 Success Criteria from the roadmap:
  1. Recruiters table has search_vector column with tsvector data and GIN index -- YES (already existed in baseline, now used in repository)
  2. search.search_index table exists with normalized schema -- YES (Plan 01 migration)
  3. Triggers on all 7 entity tables sync to search_index -- YES (Plan 02 + Plan 03 migrations)
  4. Query against search_index returns ranked results across multiple entity types with ts_rank scoring -- YES (verification queries demonstrate this)
  5. Inserting/updating a candidate, job, or company immediately reflects in search_index -- YES (AFTER triggers fire on INSERT/UPDATE)
  </action>
  <verify>
  All 9 INFRA requirements mapped to specific plan deliverables.
  All 5 roadmap success criteria satisfied.
  </verify>
  <done>
  - All INFRA requirements (01-09) covered by Plans 01, 02, 03
  - All Phase 1 success criteria achievable via the migration + code changes
  - Phase 1 Search Infrastructure is complete
  </done>
</task>

</tasks>

<verification>
1. Migration file exists and is syntactically valid SQL
2. 4 trigger functions created in `search` schema
3. 4 AFTER INSERT OR UPDATE triggers on recruiters, applications, placements, recruiter_candidates
4. 1 cascade trigger for users->recruiter search_index updates
5. 4 AFTER DELETE triggers for cleanup
6. 4 backfill INSERT...SELECT statements with correct JOINs
7. Comprehensive verification queries documented covering all 7 entity types
8. Cross-entity ts_rank search demonstrated
</verification>

<success_criteria>
- All 7 entity types have triggers syncing to search.search_index
- Relational entities (recruiters, applications, placements) correctly resolve cross-table data
- Delete triggers maintain index consistency
- Backfill populates all existing data
- Cross-entity search via ts_rank returns ranked results from all entity types
- INFRA-05 (recruiters sync), INFRA-06 (applications sync), INFRA-07 (placements sync) + recruiter_candidates complete
- Phase 1 fully complete (all 9 INFRA requirements satisfied)
</success_criteria>

<output>
After completion, create `.planning/phases/01-search-infrastructure/01-03-SUMMARY.md`
</output>
