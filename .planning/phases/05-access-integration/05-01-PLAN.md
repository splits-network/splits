---
phase: 05-access-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/shared-access-context/src/index.ts
autonomous: true

must_haves:
  truths:
    - "resolveAccessContext returns isPlatformAdmin: true when user has platform_admin row in user_roles"
    - "resolveAccessContext still returns isPlatformAdmin: true when user has platform_admin in memberships (backward compat during migration)"
    - "119+ downstream consumers receive correct isPlatformAdmin without code changes"
    - "Roles array includes platform_admin from user_roles table"
  artifacts:
    - path: "packages/shared-access-context/src/index.ts"
      provides: "Updated resolveAccessContext reading platform_admin from user_roles"
      exports: ["resolveAccessContext", "AccessContextResolver", "AccessContext"]
  key_links:
    - from: "packages/shared-access-context/src/index.ts"
      to: "user_roles table"
      via: "Supabase nested select on users"
      pattern: "user_roles.*platform_admin"
    - from: "packages/shared-access-context/src/index.ts"
      to: "services/identity-service/src/v2/users/service.ts"
      via: "findUserByClerkId calls resolveAccessContext"
      pattern: "accessContext\\.isPlatformAdmin"
---

<objective>
Update resolveAccessContext() to find platform_admin in user_roles table, making it the primary source for platform admin authorization.

Purpose: After Phase 4 migrated platform_admin data from memberships to user_roles, the access resolver must now look in user_roles for platform_admin. This is the critical integration point — 119+ downstream consumers and 13 frontend files depend on this function returning the correct isPlatformAdmin flag.

Output: Updated shared-access-context package with dual-read support (checks both user_roles and memberships for platform_admin during migration period).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-schema-data-migration/04-01-SUMMARY.md
@packages/shared-access-context/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update resolveAccessContext to read platform_admin from user_roles</name>
  <files>packages/shared-access-context/src/index.ts</files>
  <action>
Modify the `resolveAccessContext` function in `packages/shared-access-context/src/index.ts` to detect platform_admin from the user_roles table. Specific changes:

1. **Update `EntityRoleRow` interface** (bottom of file): Change `role_entity_id` from `string` to `string | null` to support platform_admin rows which have NULL role_entity_id (after Phase 4 migration made the column nullable).

2. **Update isPlatformAdmin derivation** (around line 152): Currently `isPlatformAdmin: roles.includes('platform_admin')` which works because roles is already a deduplicated union of both tables. However, we need to ensure the platform_admin role from user_roles is properly included in the roles array.

   The current code already does this correctly on lines 119-122:
   ```typescript
   const roles = [...new Set([
       ...memberships.map(m => m.role_name),
       ...userRoles.map(r => r.role_name),
   ].filter(Boolean))];
   ```

   So `platform_admin` from user_roles WILL appear in the roles array. The `isPlatformAdmin` check on line 152 (`roles.includes('platform_admin')`) will pick it up. This means the core logic already works for dual-read.

3. **Update extracting recruiter/candidate IDs** (lines 138-142): The code currently does `recruiterRole?.role_entity_id || null`. Since role_entity_id is now nullable, platform_admin rows will have null role_entity_id. The `.find()` on line 138-139 filters by role_name, so platform_admin won't interfere with recruiter/candidate ID extraction. No change needed here, but verify the logic is safe.

4. **Add a JSDoc comment** to the function docstring noting the dual-read behavior: "During migration period (v3.0 Phase 5-6), platform_admin may exist in both memberships (legacy) and user_roles (new). Both sources are checked via the deduplicated roles union."

The key insight: The existing code structure ALREADY supports reading platform_admin from user_roles because:
- The Supabase query fetches both memberships AND user_roles (lines 78-88)
- The roles array is a deduplicated union of both (lines 119-122)
- isPlatformAdmin checks the union (line 152)

The only required CODE change is making `EntityRoleRow.role_entity_id` nullable (`string | null`). Without this, TypeScript would complain when Supabase returns null for platform_admin rows.

Do NOT change the Supabase query structure. Do NOT remove the memberships read (still needed for company_admin, hiring_manager, and backward compat during migration period).
  </action>
  <verify>
Run `pnpm --filter @splits-network/shared-access-context build` to verify TypeScript compilation succeeds with the nullable role_entity_id type.
  </verify>
  <done>
EntityRoleRow.role_entity_id is `string | null`, docstring updated with dual-read note, package builds cleanly. resolveAccessContext will now correctly handle platform_admin rows from user_roles with NULL role_entity_id.
  </done>
</task>

<task type="auto">
  <name>Task 2: Rebuild dependent packages and verify no type errors</name>
  <files>packages/shared-access-context/src/index.ts</files>
  <action>
After updating the type in Task 1, rebuild the shared-access-context package and verify that downstream packages that import from it still compile:

1. Run `pnpm --filter @splits-network/shared-access-context build` to compile the package.

2. Run `pnpm --filter @splits-network/shared-access-context... build` (note the `...` which builds the package AND all its dependents) OR just build the identity-service which is the primary consumer: `pnpm --filter @splits-network/identity-service build`.

3. If any TypeScript errors appear in downstream consumers due to the nullable `role_entity_id`, check if those consumers directly access `role_entity_id` from the AccessContext interface. The AccessContext interface itself is NOT changed (it still has `recruiterId: string | null` and `candidateId: string | null`), so there should be zero downstream impact.

The EntityRoleRow interface is internal (not exported), so NO downstream consumer can be affected by this type change. The only exported types are `AccessContext` and `AccessContextResolver`, which are unchanged.

If identity-service build fails for unrelated reasons (missing deps, etc.), note the error but do not fix unrelated issues.
  </action>
  <verify>
`pnpm --filter @splits-network/shared-access-context build` exits 0. `pnpm --filter @splits-network/identity-service build` exits 0 (or note if it fails for unrelated reasons).
  </verify>
  <done>
shared-access-context builds cleanly with nullable EntityRoleRow.role_entity_id. Identity-service (primary consumer) builds without type errors from the access context change.
  </done>
</task>

</tasks>

<verification>
1. `pnpm --filter @splits-network/shared-access-context build` succeeds
2. The `EntityRoleRow` interface has `role_entity_id: string | null`
3. The `AccessContext` interface is UNCHANGED (isPlatformAdmin: boolean, recruiterId: string | null, candidateId: string | null)
4. No exported types changed — zero downstream consumer impact
5. JSDoc on resolveAccessContext documents dual-read behavior
</verification>

<success_criteria>
- shared-access-context compiles with nullable role_entity_id
- resolveAccessContext correctly handles platform_admin rows from user_roles (NULL role_entity_id)
- AccessContext interface unchanged — 119+ consumers unaffected
- Identity-service builds without shared-access-context type errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-access-integration/05-01-SUMMARY.md`
</output>
