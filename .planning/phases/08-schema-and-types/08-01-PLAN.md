---
phase: 08-schema-and-types
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260217000001_add_commute_types_and_job_level.sql
  - packages/shared-types/src/models.ts
  - packages/shared-types/src/dtos.ts
autonomous: true

must_haves:
  truths:
    - "jobs table has commute_types TEXT[] column that only accepts valid commute values"
    - "jobs table has job_level TEXT column that only accepts valid level values"
    - "Both new columns default to NULL and existing rows are unaffected"
    - "TypeScript union types exist for commute type and job level values"
    - "Job model, CreateJobDTO, and JobDTO include the new optional fields"
  artifacts:
    - path: "supabase/migrations/20260217000001_add_commute_types_and_job_level.sql"
      provides: "Database migration adding commute_types and job_level columns"
      contains: "ADD COLUMN commute_types"
    - path: "packages/shared-types/src/models.ts"
      provides: "CommuteType and JobLevel union types, updated Job interface"
      contains: "CommuteType"
    - path: "packages/shared-types/src/dtos.ts"
      provides: "Updated CreateJobDTO and JobDTO with new fields"
      contains: "commute_types"
  key_links:
    - from: "supabase/migrations/20260217000001_add_commute_types_and_job_level.sql"
      to: "packages/shared-types/src/models.ts"
      via: "Column values match TypeScript union values exactly"
      pattern: "remote.*hybrid_1.*hybrid_2.*hybrid_3.*hybrid_4.*in_office"
---

<objective>
Add commute_types (TEXT[] multi-select) and job_level (TEXT single-select) columns to the jobs table via SQL migration, then create matching TypeScript union types and update the Job model and DTOs in shared-types.

Purpose: Foundation for v4.0 -- all downstream work (API layer, frontend, search) depends on these columns and types existing.
Output: One migration file, updated models.ts and dtos.ts in shared-types.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@packages/shared-types/src/models.ts
@packages/shared-types/src/dtos.ts
@packages/shared-types/src/index.ts
@packages/shared-types/src/database/ats.types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SQL migration for commute_types and job_level columns</name>
  <files>supabase/migrations/20260217000001_add_commute_types_and_job_level.sql</files>
  <action>
Create a new migration file at `supabase/migrations/20260217000001_add_commute_types_and_job_level.sql`.

The migration adds two columns to the `jobs` table:

1. `commute_types TEXT[] DEFAULT NULL` with a CHECK constraint ensuring all array elements are contained in the valid set. Use the `<@` (contained-by) operator:
   ```sql
   ALTER TABLE public.jobs
     ADD COLUMN commute_types text[] DEFAULT NULL;

   ALTER TABLE public.jobs
     ADD CONSTRAINT jobs_commute_types_check
     CHECK (commute_types <@ ARRAY['remote', 'hybrid_1', 'hybrid_2', 'hybrid_3', 'hybrid_4', 'in_office']::text[]);
   ```

2. `job_level TEXT DEFAULT NULL` with a CHECK constraint using the same pattern as the existing `employment_type` column (see baseline migration line 1743 for reference: `CHECK (column = ANY (ARRAY[...]))`):
   ```sql
   ALTER TABLE public.jobs
     ADD COLUMN job_level text DEFAULT NULL;

   ALTER TABLE public.jobs
     ADD CONSTRAINT jobs_job_level_check
     CHECK (job_level = ANY (ARRAY['entry'::text, 'mid'::text, 'senior'::text, 'lead'::text, 'manager'::text, 'director'::text, 'vp'::text, 'c_suite'::text]));
   ```

Add a comment header to the migration file explaining what it does. Both columns default to NULL so existing jobs are unaffected.
  </action>
  <verify>
Read the migration file and confirm:
- commute_types column is TEXT[] with DEFAULT NULL
- commute_types CHECK uses `<@` operator with all 6 valid values
- job_level column is TEXT with DEFAULT NULL
- job_level CHECK uses `= ANY(ARRAY[...])` with all 8 valid values
- Constraint names follow pattern: jobs_commute_types_check, jobs_job_level_check
  </verify>
  <done>Migration file exists with correct ALTER TABLE statements, CHECK constraints match the decided values exactly, and both columns default to NULL.</done>
</task>

<task type="auto">
  <name>Task 2: Add TypeScript union types and update Job model and DTOs</name>
  <files>packages/shared-types/src/models.ts, packages/shared-types/src/dtos.ts, packages/shared-types/src/index.ts</files>
  <action>
**In `packages/shared-types/src/models.ts`:**

1. Add two new union types immediately after the existing `EmploymentType` type (line ~171):
   ```typescript
   export type CommuteType = 'remote' | 'hybrid_1' | 'hybrid_2' | 'hybrid_3' | 'hybrid_4' | 'in_office';

   export type JobLevel = 'entry' | 'mid' | 'senior' | 'lead' | 'manager' | 'director' | 'vp' | 'c_suite';
   ```

2. Add two new optional fields to the `Job` interface, after the `open_to_relocation` field (around line 188):
   ```typescript
   commute_types?: CommuteType[];
   job_level?: JobLevel;
   ```

**In `packages/shared-types/src/dtos.ts`:**

1. Add import for the new types at the top of the file (or use inline types -- check if dtos.ts already imports from models.ts. If not, define inline):
   - If dtos.ts does NOT import from models.ts: use string literal types inline in the DTO fields
   - If dtos.ts DOES import from models.ts: import CommuteType and JobLevel

2. Add to `CreateJobDTO` (after existing optional fields like `status`):
   ```typescript
   commute_types?: CommuteType[];  // or string[] if not importing
   job_level?: string;
   ```

3. Add to `JobDTO` (after existing fields like `status`):
   ```typescript
   commute_types?: CommuteType[] | null;  // or string[] | null if not importing
   job_level?: string | null;
   ```
   Note: JobDTO fields are nullable because database columns can be NULL.

**In `packages/shared-types/src/index.ts`:**

Add `CommuteType` and `JobLevel` to the named exports from `./models` in the existing `export type { ... } from './models'` block (around line 20-45).

**Important:** Do NOT edit `packages/shared-types/src/supabase/database.types.ts` -- that file is auto-generated. After the user applies the migration and runs `supabase gen types typescript`, it will update automatically.
  </action>
  <verify>
1. Run `pnpm --filter @splits-network/shared-types build` to confirm types compile without errors.
2. Grep for `CommuteType` in models.ts and index.ts to confirm the type is defined and exported.
3. Grep for `job_level` in dtos.ts and models.ts to confirm the field is present in Job, CreateJobDTO, and JobDTO.
  </verify>
  <done>
- CommuteType union type with 6 values exists in models.ts and is exported from index.ts
- JobLevel union type with 8 values exists in models.ts and is exported from index.ts
- Job interface has optional commute_types and job_level fields
- CreateJobDTO has optional commute_types and job_level fields
- JobDTO has optional nullable commute_types and job_level fields
- shared-types package builds successfully
  </done>
</task>

</tasks>

<verification>
1. Migration file exists at `supabase/migrations/20260217000001_add_commute_types_and_job_level.sql`
2. `pnpm --filter @splits-network/shared-types build` succeeds
3. CommuteType has exactly: 'remote' | 'hybrid_1' | 'hybrid_2' | 'hybrid_3' | 'hybrid_4' | 'in_office'
4. JobLevel has exactly: 'entry' | 'mid' | 'senior' | 'lead' | 'manager' | 'director' | 'vp' | 'c_suite'
5. Values in TypeScript types match values in SQL CHECK constraints exactly
</verification>

<success_criteria>
- SQL migration adds both columns with correct CHECK constraints and NULL defaults
- TypeScript union types match SQL constraint values exactly (6 commute types, 8 job levels)
- Job model and both DTOs include new optional fields
- shared-types package compiles without errors
- No existing code is broken (both columns are optional/nullable)
</success_criteria>

<note>
After applying the migration to the database, the user must run `supabase gen types typescript` to regenerate `packages/shared-types/src/supabase/database.types.ts`. The auto-generated file will then include the new columns, and the `Job` type alias in `database/ats.types.ts` (which is `DbTable<'jobs'>`) will automatically pick up the new fields.
</note>

<output>
After completion, create `.planning/phases/08-schema-and-types/08-01-SUMMARY.md`
</output>
