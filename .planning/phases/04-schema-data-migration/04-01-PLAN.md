---
phase: 04-schema-data-migration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260215000001_platform_admin_to_user_roles.sql
autonomous: true

must_haves:
  truths:
    - "role_entity_id column in user_roles is nullable (platform_admin rows have NULL)"
    - "Partial unique index prevents duplicate platform_admin rows per user"
    - "All existing platform admins in memberships have matching rows in user_roles"
    - "Revoking platform_admin via deleted_at immediately excludes row from unique index and active queries"
    - "Migration is reversible with documented rollback SQL in comments"
  artifacts:
    - path: "supabase/migrations/20260215000001_platform_admin_to_user_roles.sql"
      provides: "Schema change + data migration + validation + rollback docs"
      contains: "ALTER TABLE public.user_roles ALTER COLUMN role_entity_id DROP NOT NULL"
  key_links:
    - from: "supabase/migrations/20260215000001_platform_admin_to_user_roles.sql"
      to: "public.user_roles"
      via: "ALTER TABLE DROP NOT NULL + INSERT from memberships"
      pattern: "ALTER TABLE.*DROP NOT NULL"
    - from: "supabase/migrations/20260215000001_platform_admin_to_user_roles.sql"
      to: "public.memberships"
      via: "SELECT platform_admin rows for migration"
      pattern: "FROM public\\.memberships.*role_name.*platform_admin"
---

<objective>
Create a Supabase migration that makes role_entity_id nullable in user_roles, migrates all platform_admin rows from memberships into user_roles, validates the migration count atomically, and documents rollback SQL.

Purpose: This is the foundational schema change for the v3.0 Platform Admin Restructure. Once complete, user_roles can store both entity-linked roles (recruiter/candidate with role_entity_id) AND system-level roles (platform_admin with NULL role_entity_id).

Output: A single SQL migration file that can be applied to the Supabase database.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Key source files:
@supabase/migrations/20260212000001_split_user_roles_into_memberships.sql
@supabase/migrations/20260211000005_drop_role_entity_type_column.sql
@supabase/migrations/20260211000003_create_user_roles_table.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create platform_admin migration SQL file</name>
  <files>supabase/migrations/20260215000001_platform_admin_to_user_roles.sql</files>
  <action>
Create the migration file with the following steps, each in a clearly commented section. The entire migration runs in a single implicit Supabase transaction.

**IMPORTANT CONTEXT — Current user_roles schema:**
- Columns: `id` (UUID PK), `user_id` (UUID NOT NULL FK), `role_name` (TEXT NOT NULL FK), `role_entity_id` (UUID **NOT NULL**), `created_at`, `updated_at`, `deleted_at`
- The `role_entity_type` column was ALREADY DROPPED in migration `20260211000005`
- The `organization_id` and `company_id` columns were ALREADY DROPPED in migration `20260212000001`
- Current unique index: `uq_user_role_entity_assignment ON (user_id, role_name, role_entity_id) WHERE deleted_at IS NULL`

**Step 1: Drop NOT NULL constraint on role_entity_id**
```sql
ALTER TABLE public.user_roles ALTER COLUMN role_entity_id DROP NOT NULL;
```

**Step 2: Drop and recreate the existing unique index to handle NULLs**
The current unique index `uq_user_role_entity_assignment` is `(user_id, role_name, role_entity_id) WHERE deleted_at IS NULL`. This doesn't work for platform_admin because all platform_admin rows would have role_entity_id=NULL, and NULLs are not equal in unique indexes — meaning it wouldn't prevent duplicates.

Drop it and create TWO partial indexes:
1. Entity-linked uniqueness (for recruiter/candidate — role_entity_id IS NOT NULL):
   ```sql
   CREATE UNIQUE INDEX uq_user_role_entity ON public.user_roles (user_id, role_name, role_entity_id) WHERE deleted_at IS NULL AND role_entity_id IS NOT NULL;
   ```
2. Platform admin uniqueness (role_entity_id IS NULL — one per user):
   ```sql
   CREATE UNIQUE INDEX uq_user_role_platform_admin ON public.user_roles (user_id, role_name) WHERE deleted_at IS NULL AND role_name = 'platform_admin';
   ```

**Step 3: Migrate platform_admin rows from memberships to user_roles**
Insert platform_admin rows from memberships. Use `ON CONFLICT DO NOTHING` for idempotency. Only migrate active rows (deleted_at IS NULL).
```sql
INSERT INTO public.user_roles (id, user_id, role_name, role_entity_id, created_at, updated_at)
SELECT
    gen_random_uuid(),
    m.user_id,
    m.role_name,
    NULL,
    m.created_at,
    COALESCE(m.updated_at, now())
FROM public.memberships m
WHERE m.role_name = 'platform_admin'
  AND m.deleted_at IS NULL
ON CONFLICT DO NOTHING;
```

**Step 4: Atomic validation — hard fail on count mismatch**
Use a DO block to count source platform_admin rows in memberships vs migrated rows in user_roles. If counts don't match, RAISE EXCEPTION to abort the entire transaction.
```sql
DO $$
DECLARE
    source_count INTEGER;
    migrated_count INTEGER;
BEGIN
    SELECT COUNT(*) INTO source_count
    FROM public.memberships
    WHERE role_name = 'platform_admin' AND deleted_at IS NULL;

    SELECT COUNT(*) INTO migrated_count
    FROM public.user_roles
    WHERE role_name = 'platform_admin' AND deleted_at IS NULL;

    IF source_count <> migrated_count THEN
        RAISE EXCEPTION 'Platform admin migration count mismatch: % in memberships, % in user_roles. Aborting.', source_count, migrated_count;
    END IF;

    RAISE NOTICE 'Platform admin migration validated: % rows migrated successfully', migrated_count;
END $$;
```

**Step 5: Update table and column comments**
```sql
COMMENT ON TABLE public.user_roles IS 'Role assignments: entity-linked (recruiter, candidate) with role_entity_id, and system-level (platform_admin) with NULL role_entity_id.';
COMMENT ON COLUMN public.user_roles.role_entity_id IS 'Links to domain entity: recruiters.id for recruiter, candidates.id for candidate. NULL for system-level roles (platform_admin).';
```

**Step 6: Rollback documentation**
Add a clearly commented rollback section at the bottom of the file (commented out SQL). The rollback should:
1. Delete migrated platform_admin rows from user_roles
2. Restore NOT NULL on role_entity_id
3. Drop the two new indexes and recreate the original single index

Use this exact pattern:
```sql
-- ============================================================================
-- ROLLBACK (run manually if needed — reverse the migration)
-- ============================================================================
-- DELETE FROM public.user_roles WHERE role_name = 'platform_admin';
-- ALTER TABLE public.user_roles ALTER COLUMN role_entity_id SET NOT NULL;
-- DROP INDEX IF EXISTS uq_user_role_platform_admin;
-- DROP INDEX IF EXISTS uq_user_role_entity;
-- CREATE UNIQUE INDEX uq_user_role_entity_assignment ON public.user_roles (user_id, role_name, role_entity_id) WHERE deleted_at IS NULL;
```

Follow the section-comment pattern from the reference migration (`20260212000001_split_user_roles_into_memberships.sql`): use `-- ============================================================================` section headers with step numbers.
  </action>
  <verify>
1. File exists at `supabase/migrations/20260215000001_platform_admin_to_user_roles.sql`
2. File contains `ALTER TABLE public.user_roles ALTER COLUMN role_entity_id DROP NOT NULL`
3. File contains `CREATE UNIQUE INDEX uq_user_role_platform_admin` with `WHERE deleted_at IS NULL AND role_name = 'platform_admin'`
4. File contains `CREATE UNIQUE INDEX uq_user_role_entity` with `WHERE deleted_at IS NULL AND role_entity_id IS NOT NULL`
5. File contains `DROP INDEX IF EXISTS uq_user_role_entity_assignment` (removes old index)
6. File contains `INSERT INTO public.user_roles` selecting from `public.memberships` where `role_name = 'platform_admin'`
7. File contains `ON CONFLICT DO NOTHING` for idempotency
8. File contains `RAISE EXCEPTION` validation block that aborts on count mismatch
9. File contains commented-out ROLLBACK section with reverse operations
10. File does NOT reference `role_entity_type` (column was already dropped)
11. File does NOT reference `organization_id` or `company_id` on user_roles (columns were already dropped)
  </verify>
  <done>
A complete, atomic SQL migration file exists that:
- Makes role_entity_id nullable in user_roles
- Replaces the single unique index with two partial indexes (entity-linked + platform_admin)
- Migrates all active platform_admin rows from memberships to user_roles with NULL role_entity_id
- Validates migration count atomically (aborts transaction on mismatch)
- Documents rollback SQL in comments
- Follows the established migration file naming and comment conventions
  </done>
</task>

</tasks>

<verification>
1. The migration file exists and follows the naming convention `YYYYMMDD######_descriptive_name.sql`
2. All 5 phase success criteria are addressed:
   - SC1: role_entity_id nullable — `ALTER TABLE ... DROP NOT NULL`
   - SC2: Partial unique index — `uq_user_role_platform_admin` prevents duplicate platform_admin per user
   - SC3: Count validation — DO block with RAISE EXCEPTION on mismatch
   - SC4: deleted_at filtering — both unique indexes have `WHERE deleted_at IS NULL`, so soft-deleted rows are excluded
   - SC5: Reversibility — commented ROLLBACK section with exact reverse SQL
3. No references to dropped columns (role_entity_type, organization_id, company_id)
4. ON CONFLICT DO NOTHING ensures idempotency
5. RAISE EXCEPTION in validation block ensures atomic rollback on failure
</verification>

<success_criteria>
- Migration file created at `supabase/migrations/20260215000001_platform_admin_to_user_roles.sql`
- File contains schema change (DROP NOT NULL), index restructuring, data migration, validation, and rollback docs
- All 5 phase success criteria from ROADMAP.md are verifiably addressed in the SQL
</success_criteria>

<output>
After completion, create `.planning/phases/04-schema-data-migration/04-01-SUMMARY.md`
</output>
