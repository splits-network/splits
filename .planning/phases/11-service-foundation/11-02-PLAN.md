---
phase: 11-service-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260220000001_create_gpt_oauth_tables.sql
autonomous: true

must_haves:
  truths:
    - "gpt_authorization_codes table exists with code, code_challenge, code_challenge_method, clerk_user_id, redirect_uri, expires_at, used_at columns"
    - "gpt_refresh_tokens table exists with token_hash, clerk_user_id, expires_at, revoked_at, rotated_to columns"
    - "gpt_sessions table exists with clerk_user_id, last_active, created_at, refresh_token_id columns"
    - "gpt_oauth_events table exists with event_type, clerk_user_id, metadata JSONB, ip_address, created_at columns"
    - "All lookup indexes exist: code, token_hash, clerk_user_id, event timestamp, composite and partial indexes for active-only queries"
  artifacts:
    - path: "supabase/migrations/20260220000001_create_gpt_oauth_tables.sql"
      provides: "Database migration creating all 4 GPT OAuth tables with indexes"
      min_lines: 80
  key_links:
    - from: "gpt_sessions"
      to: "gpt_refresh_tokens"
      via: "refresh_token_id FK"
      pattern: "REFERENCES.*gpt_refresh_tokens"
    - from: "gpt_refresh_tokens"
      to: "gpt_refresh_tokens"
      via: "rotated_to self-reference FK"
      pattern: "REFERENCES.*gpt_refresh_tokens"
---

<objective>
Create the database migration for all 4 GPT OAuth tables with correct schemas, constraints, indexes, and foreign key relationships.

Purpose: Establish the data layer for GPT OAuth flow (authorization codes, refresh tokens, sessions, audit events) so Phase 12 can implement OAuth endpoints directly.
Output: A single SQL migration file that creates all 4 tables in the public schema.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-service-foundation/11-CONTEXT.md

# Migration format reference
@supabase/migrations/20260217000001_add_commute_types_and_job_level.sql
@supabase/migrations/20260215000001_platform_admin_to_user_roles.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GPT OAuth tables migration</name>
  <files>supabase/migrations/20260220000001_create_gpt_oauth_tables.sql</files>
  <action>
Create a single migration file with all 4 tables. Follow the existing migration naming convention (YYYYMMDDHHMMSS_description.sql). All tables go in the `public` schema (single Supabase Postgres, no separate schemas per service).

**Table 1: gpt_authorization_codes**
```sql
CREATE TABLE public.gpt_authorization_codes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    code TEXT NOT NULL UNIQUE,
    code_challenge TEXT NOT NULL,
    code_challenge_method TEXT NOT NULL DEFAULT 'S256' CHECK (code_challenge_method IN ('S256', 'plain')),
    clerk_user_id TEXT NOT NULL,
    redirect_uri TEXT NOT NULL,
    expires_at TIMESTAMPTZ NOT NULL,
    used_at TIMESTAMPTZ DEFAULT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);
```
- `code`: opaque authorization code string, unique
- `code_challenge` + `code_challenge_method`: PKCE support (S256 or plain)
- `clerk_user_id`: the Clerk user who authorized
- `redirect_uri`: the redirect_uri from the authorization request (validated against env)
- `expires_at`: TTL column, authorization codes expire quickly (default 10 min set at app level)
- `used_at`: NULL means unused, timestamp means already exchanged for tokens

Indexes:
- `idx_gpt_auth_codes_code` ON (code) -- primary lookup
- `idx_gpt_auth_codes_clerk_user_id` ON (clerk_user_id) -- find codes by user
- Partial index `idx_gpt_auth_codes_active` ON (code) WHERE used_at IS NULL AND expires_at > now() -- fast lookup for valid unused codes

**Table 2: gpt_refresh_tokens**
```sql
CREATE TABLE public.gpt_refresh_tokens (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    token_hash TEXT NOT NULL UNIQUE,
    clerk_user_id TEXT NOT NULL,
    expires_at TIMESTAMPTZ NOT NULL,
    revoked_at TIMESTAMPTZ DEFAULT NULL,
    rotated_to UUID DEFAULT NULL REFERENCES public.gpt_refresh_tokens(id),
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);
```
- `token_hash`: SHA-256 hash of the opaque refresh token (never store raw tokens)
- `clerk_user_id`: owner of this refresh token
- `expires_at`: TTL column
- `revoked_at`: NULL means active, timestamp means revoked
- `rotated_to`: self-referencing FK pointing to the new token when this one was rotated

Indexes:
- `idx_gpt_refresh_tokens_hash` ON (token_hash) -- primary lookup
- `idx_gpt_refresh_tokens_clerk_user_id` ON (clerk_user_id) -- find tokens by user
- Partial index `idx_gpt_refresh_tokens_active` ON (token_hash) WHERE revoked_at IS NULL AND expires_at > now() -- fast lookup for valid active tokens

**Table 3: gpt_sessions**
```sql
CREATE TABLE public.gpt_sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    clerk_user_id TEXT NOT NULL,
    refresh_token_id UUID REFERENCES public.gpt_refresh_tokens(id),
    last_active TIMESTAMPTZ NOT NULL DEFAULT now(),
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);
```
- `clerk_user_id`: the candidate user
- `refresh_token_id`: FK to current refresh token (nullable during authorization code phase)
- `last_active`: updated on each GPT action

Indexes:
- `idx_gpt_sessions_clerk_user_id` ON (clerk_user_id) -- find sessions by user
- `idx_gpt_sessions_refresh_token_id` ON (refresh_token_id) -- find session by refresh token

**Table 4: gpt_oauth_events**
```sql
CREATE TABLE public.gpt_oauth_events (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    event_type TEXT NOT NULL,
    clerk_user_id TEXT,
    metadata JSONB DEFAULT '{}',
    ip_address TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);
```
- `event_type`: e.g., 'authorize', 'token_exchange', 'token_refresh', 'token_revoke', 'job_search', 'resume_analyze'
- `clerk_user_id`: nullable (some events may be pre-auth)
- `metadata`: flexible JSONB for event-specific data
- `ip_address`: optional, for security auditing

Indexes:
- `idx_gpt_oauth_events_type` ON (event_type) -- filter by event type
- `idx_gpt_oauth_events_clerk_user_id` ON (clerk_user_id) -- find events by user
- `idx_gpt_oauth_events_created_at` ON (created_at DESC) -- time-range queries, recent first
- Composite `idx_gpt_oauth_events_user_type` ON (clerk_user_id, event_type) -- user + type filtering

Add a file header comment explaining the purpose (GPT OAuth infrastructure for v5.0 Custom GPT).
Create tables in dependency order: gpt_refresh_tokens first (referenced by others), then gpt_authorization_codes, gpt_sessions, gpt_oauth_events.
  </action>
  <verify>
Visually verify the SQL file has correct syntax: all CREATE TABLE statements, all CREATE INDEX statements, proper foreign key references.
Count: should have 4 CREATE TABLE + ~10 CREATE INDEX statements.
  </verify>
  <done>Migration file exists with 4 tables (gpt_authorization_codes, gpt_refresh_tokens, gpt_sessions, gpt_oauth_events), all with correct column types, constraints, FKs, and indexes.</done>
</task>

</tasks>

<verification>
1. Migration file exists at supabase/migrations/20260220000001_create_gpt_oauth_tables.sql
2. File contains 4 CREATE TABLE statements
3. gpt_authorization_codes has: code (UNIQUE), code_challenge, code_challenge_method (CHECK), clerk_user_id, redirect_uri, expires_at, used_at
4. gpt_refresh_tokens has: token_hash (UNIQUE), clerk_user_id, expires_at, revoked_at, rotated_to (self-ref FK)
5. gpt_sessions has: clerk_user_id, refresh_token_id (FK to gpt_refresh_tokens), last_active
6. gpt_oauth_events has: event_type, clerk_user_id (nullable), metadata (JSONB), ip_address
7. All indexes created including partial indexes for active-only queries
8. Tables created in correct dependency order (gpt_refresh_tokens before gpt_sessions)
</verification>

<success_criteria>
- Single migration file with all 4 tables
- Foreign key relationships correct (gpt_sessions -> gpt_refresh_tokens, gpt_refresh_tokens -> gpt_refresh_tokens self-ref)
- Partial indexes for active authorization codes and active refresh tokens
- PKCE columns (code_challenge, code_challenge_method) present on gpt_authorization_codes
- TTL columns (expires_at) on both gpt_authorization_codes and gpt_refresh_tokens
</success_criteria>

<output>
After completion, create `.planning/phases/11-service-foundation/11-02-SUMMARY.md`
</output>
