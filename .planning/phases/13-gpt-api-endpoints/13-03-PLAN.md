---
phase: 13-gpt-api-endpoints
plan: 03
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - services/gpt-service/src/v2/actions/routes.ts
autonomous: true

must_haves:
  truths:
    - "Application submission returns CONFIRMATION_REQUIRED with summary on first call (confirmed not set or false)"
    - "Application submission executes submission only when confirmed=true with valid confirmation token on second call"
    - "Required pre-screen questions must be answered before submission -- endpoint returns question list if missing"
    - "Duplicate applications are blocked with error including original application date"
    - "Pre-screen answers collected conversationally by GPT are saved with the application"
  artifacts:
    - path: "services/gpt-service/src/v2/actions/routes.ts"
      provides: "POST /api/v2/applications/submit route handler with two-step confirmation flow"
      min_lines: 150
  key_links:
    - from: "services/gpt-service/src/v2/actions/routes.ts"
      to: "services/gpt-service/src/v2/actions/helpers.ts"
      via: "generateConfirmationToken, getConfirmationToken, deleteConfirmationToken"
      pattern: "generateConfirmationToken|getConfirmationToken|deleteConfirmationToken"
    - from: "services/gpt-service/src/v2/actions/routes.ts"
      to: "services/gpt-service/src/v2/actions/repository.ts"
      via: "checkDuplicateApplication, createApplication, savePreScreenAnswers, getPreScreenQuestions"
      pattern: "repository\\.checkDuplicate|repository\\.createApplication|repository\\.savePreScreen|repository\\.getPreScreen"
---

<objective>
Implement the application submission endpoint with the two-step confirmation safety pattern. ChatGPT sends a POST to submit an application; the first call returns CONFIRMATION_REQUIRED with a detailed summary, and only when the user confirms (confirmed=true + confirmation_token) does the actual submission happen.

Purpose: ENDP-04 (confirmation safety), ENDP-05 (pre-screen answers), ENDP-07 (candidate-scoped auth). This is the only write endpoint and the most complex flow -- the confirmation pattern prevents accidental submissions through AI.

Output: POST /api/v2/applications/submit handler added to routes.ts
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13-gpt-api-endpoints/13-CONTEXT.md

@services/gpt-service/src/v2/oauth/middleware.ts
@services/gpt-service/src/v2/oauth/types.ts

Reference Plan 01 SUMMARY for types, repository, and helpers that are available.
Reference Plan 02 SUMMARY for existing route structure to follow.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement POST /api/v2/applications/submit with confirmation safety</name>
  <files>
    services/gpt-service/src/v2/actions/routes.ts
  </files>
  <action>
Add route to the existing `registerActionRoutes` function in `services/gpt-service/src/v2/actions/routes.ts`.

**Route: POST /api/v2/applications/submit**
- Scope: `applications:write`
- PreHandler: `[extractGptAuth(oauthService), requireScope('applications:write')]`
- Body: GptSubmitApplicationRequest (job_id, confirmed?, confirmation_token?, pre_screen_answers?, cover_letter?)

**Handler logic -- two paths based on `confirmed` flag:**

**Path A: First call (confirmed is falsy or missing) -- Return CONFIRMATION_REQUIRED**

1. Get clerkUserId from `request.gptAuth!.clerkUserId`
2. Resolve candidateId via `repository.resolveCandidateId(clerkUserId)`
   - If no candidateId: 404 with `gptError('NOT_FOUND', 'No candidate profile found', { suggestion: 'Create a profile at applicant.network/portal/profile' })`
3. Validate job_id is present
   - If missing: 400 with `gptError('INVALID_REQUEST', 'job_id is required')`
4. Check for duplicate application: `repository.checkDuplicateApplication(candidateId, job_id)`
   - If exists: 409 with `gptError('DUPLICATE_APPLICATION', 'You already applied to this job on ${formatDate(existing.created_at)}', { suggestion: 'Check your application status instead' })`
5. Fetch job details: `repository.getJobDetail(job_id)`
   - If null: 404 with `gptError('NOT_FOUND', 'Job not found or no longer active')`
6. Fetch pre-screen questions: `repository.getPreScreenQuestions(job_id)`
7. Check required pre-screen questions vs provided answers:
   - Get required questions (where is_required = true)
   - Get provided answer question_ids from request body
   - Find missing required questions (required but not in provided answers)
   - If missing AND body has no pre_screen_answers at all (first attempt), return 400 with:
     ```json
     {
       "error": {
         "code": "MISSING_PRE_SCREEN_ANSWERS",
         "message": "This job requires answers to pre-screen questions before applying",
         "questions": [{ "id": "...", "question": "...", "type": "...", "is_required": true }]
       }
     }
     ```
   - If some answers provided but required ones missing, return 400 with same error including only the missing questions
8. Generate confirmation token: `generateConfirmationToken(clerkUserId, job_id, candidateId, pre_screen_answers, cover_letter)`
9. Build confirmation summary:
   - job_title, company_name from job details
   - requirements_summary: first 5 mandatory requirements as string array
   - pre_screen_answers_provided: map provided answers with question text
   - missing_required_questions: any required questions not yet answered (should be empty if step 7 passed)
   - warnings: add "No cover letter provided" if cover_letter is empty, add "X optional pre-screen questions not answered" if applicable
   - confirmation_token: the generated token ID
   - expires_at: token expiry as ISO string
10. Return 200 with:
    ```json
    {
      "data": {
        "status": "CONFIRMATION_REQUIRED",
        "message": "Please review the application details and confirm submission",
        "summary": { ...GptConfirmationSummary }
      }
    }
    ```

**Path B: Second call (confirmed === true) -- Execute submission**

1. Validate confirmation_token is present
   - If missing: 400 with `gptError('INVALID_REQUEST', 'confirmation_token is required when confirmed=true')`
2. Retrieve token: `getConfirmationToken(confirmation_token)`
   - If not found or expired: 400 with `gptError('CONFIRMATION_EXPIRED', 'Confirmation token has expired. Please start the application process again.')`
3. Validate token belongs to this user:
   - Check `token.clerkUserId === request.gptAuth!.clerkUserId`
   - If mismatch: 403 with `gptError('INVALID_REQUEST', 'Confirmation token does not belong to this user')`
4. Re-check for duplicate (race condition guard): `repository.checkDuplicateApplication(token.candidateId, token.jobId)`
   - If exists: delete token, return 409 duplicate error
5. Create the application: `repository.createApplication(token.candidateId, token.jobId, token.coverLetter)`
6. Save pre-screen answers if present: `repository.savePreScreenAnswers(application.id, token.preScreenAnswers)`
7. Delete the confirmation token: `deleteConfirmationToken(confirmation_token)`
8. Publish audit event via EventPublisher (if available):
   ```
   eventPublisher.publish('gpt.action.application_submitted', {
     application_id: application.id,
     candidate_id: token.candidateId,
     job_id: token.jobId,
     clerk_user_id: token.clerkUserId,
   })
   ```
9. Return 201 with:
    ```json
    {
      "data": {
        "status": "SUBMITTED",
        "message": "Application submitted successfully",
        "application": {
          "id": application.id,
          "job_title": "...",
          "company_name": "...",
          "applied_date": "YYYY-MM-DD",
          "status_label": "Submitted"
        }
      }
    }
    ```

**Note:** The EventPublisher needs to be passed through the registerActionRoutes config. Update the config interface to accept an optional `eventPublisher?: EventPublisher` parameter.

**Error handling:** Wrap the entire handler in try/catch. Unexpected errors return 500 with `gptError('INTERNAL_ERROR', 'Failed to process application')`.
  </action>
  <verify>
    Run `cd g:/code/splits.network && npx tsc --noEmit --project services/gpt-service/tsconfig.json` -- should compile without errors.
  </verify>
  <done>
    POST /api/v2/applications/submit implements two-step confirmation: first call returns CONFIRMATION_REQUIRED with summary, second call with confirmed=true + token executes submission. Pre-screen questions are validated. Duplicates are blocked. Audit events are published.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit --project services/gpt-service/tsconfig.json` passes
- POST /api/v2/applications/submit route is registered with applications:write scope
- First call (no confirmed) returns CONFIRMATION_REQUIRED with summary
- Second call (confirmed=true + valid token) creates application and returns SUBMITTED
- Missing pre-screen answers return MISSING_PRE_SCREEN_ANSWERS with question list
- Duplicate applications return 409 with original application date
- Expired confirmation tokens return CONFIRMATION_EXPIRED
- Audit event published on successful submission
</verification>

<success_criteria>
Application submission endpoint fully implements the two-step confirmation safety pattern per CONTEXT.md decisions. Required pre-screen questions are enforced. Duplicates are blocked. Confirmation tokens expire after 15 minutes.
</success_criteria>

<output>
After completion, create `.planning/phases/13-gpt-api-endpoints/13-03-SUMMARY.md`
</output>
