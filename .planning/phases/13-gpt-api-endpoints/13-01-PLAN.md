---
phase: 13-gpt-api-endpoints
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - services/gpt-service/src/v2/actions/types.ts
  - services/gpt-service/src/v2/actions/repository.ts
  - services/gpt-service/src/v2/actions/helpers.ts
  - services/gpt-service/src/v2/routes.ts
autonomous: true

must_haves:
  truths:
    - "GPT action types define structured request/response shapes for all endpoints"
    - "Repository can query jobs, applications, candidates, and documents tables with candidate-scoped isolation"
    - "Error helper produces consistent { error: { code, message, suggestion } } response format"
  artifacts:
    - path: "services/gpt-service/src/v2/actions/types.ts"
      provides: "Request/response types, filter types, confirmation token type, GPT-formatted response shapes"
      min_lines: 60
    - path: "services/gpt-service/src/v2/actions/repository.ts"
      provides: "GptActionRepository with Supabase queries for jobs, applications, candidates, documents, pre-screen questions"
      min_lines: 80
    - path: "services/gpt-service/src/v2/actions/helpers.ts"
      provides: "Error response builder, GPT-formatted job/application mappers, confirmation token store"
      min_lines: 40
  key_links:
    - from: "services/gpt-service/src/v2/actions/repository.ts"
      to: "@supabase/supabase-js"
      via: "createClient"
      pattern: "createClient.*supabase"
    - from: "services/gpt-service/src/v2/actions/repository.ts"
      to: "@splits-network/shared-access-context"
      via: "resolveAccessContext"
      pattern: "resolveAccessContext"
---

<objective>
Create the foundation layer for GPT API action endpoints: TypeScript types, Supabase repository, error/response helpers, and confirmation token store.

Purpose: All 5 GPT action endpoints (job search, job details, application status, application submission, resume analysis) share types, repository access, and error formatting. Building this layer first prevents duplication and ensures consistency.

Output: types.ts, repository.ts, helpers.ts in services/gpt-service/src/v2/actions/
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-gpt-api-endpoints/13-CONTEXT.md

@services/gpt-service/src/v2/routes.ts
@services/gpt-service/src/v2/oauth/types.ts
@services/gpt-service/src/v2/oauth/middleware.ts
@services/gpt-service/src/index.ts
@packages/shared-access-context/src/index.ts
@services/ats-service/src/v2/jobs/repository.ts
@services/ats-service/src/v2/applications/repository.ts
@services/ats-service/src/v2/jobs/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create types, error helpers, and confirmation token store</name>
  <files>
    services/gpt-service/src/v2/actions/types.ts
    services/gpt-service/src/v2/actions/helpers.ts
  </files>
  <action>
Create `services/gpt-service/src/v2/actions/types.ts`:

Define TypeScript interfaces for all GPT action endpoints:

1. **Job search types:**
   - `GptJobSearchParams`: { keywords?: string, location?: string, commute_type?: string, job_level?: string, page?: number } (page defaults to 1, limit hardcoded to 5)
   - `GptJobSearchResult`: { id, title, company_name, location, commute_types, posted_date, salary_range (string like "$80k-$120k" or null), job_level, summary (1-2 sentences from description, truncated at ~200 chars) }
   - `GptJobSearchResponse`: { jobs: GptJobSearchResult[], pagination: { page, total_pages, total_results } }

2. **Job details types:**
   - `GptJobDetail`: extends GptJobSearchResult with { description, responsibilities, requirements: { text, type: 'mandatory'|'preferred' }[], pre_screen_questions: { id, question, type, is_required }[], company: { name, industry, location, website, description } }

3. **Application status types:**
   - `GptApplicationStatus`: { id, job_title, company_name, status_label (human-readable), applied_date, last_updated }
   - `GptApplicationListParams`: { include_inactive?: boolean, page?: number }

4. **Application submission types:**
   - `GptSubmitApplicationRequest`: { job_id: string, confirmed?: boolean, confirmation_token?: string, pre_screen_answers?: { question_id: string, answer: string }[], cover_letter?: string }
   - `GptConfirmationSummary`: { confirmation_token, expires_at, job_title, company_name, requirements_summary: string[], pre_screen_answers_provided: { question, answer }[], missing_required_questions: { id, question }[], warnings: string[] }

5. **Resume analysis types:**
   - `GptResumeAnalysisRequest`: { job_id: string, resume_text?: string }
   - `GptResumeAnalysisResponse`: { fit_score: number (0-100), strengths: string[], gaps: string[], recommendation: string, overall_summary: string }

6. **Error types:**
   - `GptErrorResponse`: { error: { code: string, message: string, suggestion?: string, required_scope?: string } }
   - Error code constants: NOT_FOUND, INVALID_REQUEST, DUPLICATE_APPLICATION, CONFIRMATION_REQUIRED, MISSING_PRE_SCREEN_ANSWERS, RESUME_NOT_FOUND, CONFIRMATION_EXPIRED, TOKEN_EXPIRED, TOKEN_REVOKED, TOKEN_INVALID, INSUFFICIENT_SCOPE, INTERNAL_ERROR

7. **Confirmation token type:**
   - `ConfirmationToken`: { token: string, clerkUserId: string, jobId: string, candidateId: string, preScreenAnswers?: { question_id: string, answer: string }[], coverLetter?: string, expiresAt: Date }

Create `services/gpt-service/src/v2/actions/helpers.ts`:

1. **Error response builder:**
   - `gptError(code: string, message: string, extras?: { suggestion?: string, required_scope?: string }): GptErrorResponse` -- returns structured error object matching the format from CONTEXT.md decisions
   - Do NOT wrap in `{ data: ... }` -- error responses use `{ error: { ... } }` format

2. **GPT-formatted job mapper:**
   - `formatJobForGpt(job: any): GptJobSearchResult` -- maps raw Supabase job row (with company join) to GPT-friendly format
   - Salary range: if salary_min and salary_max exist, format as "$XXk-$XXk"; if only one, show that; if neither, null
   - Summary: take first ~200 chars of description, truncate at word boundary, append "..."
   - Posted date: format created_at as "YYYY-MM-DD"

3. **Application status label mapper:**
   - `formatStageLabel(stage: string): string` -- maps internal stage names to human-readable labels
   - Map: draft -> "Draft", submitted -> "Submitted", company_review -> "Under Review", interview -> "Interviewing", offer -> "Offer Received", hired -> "Hired", rejected -> "Not Selected", withdrawn -> "Withdrawn", ai_review -> "Under Review", screen -> "Screening", recruiter_proposed -> "Recruiter Proposed", recruiter_request -> "Changes Requested"

4. **Confirmation token store (in-memory Map):**
   - `const confirmationTokens = new Map<string, ConfirmationToken>()`
   - `storeConfirmationToken(token: ConfirmationToken): void` -- stores token
   - `getConfirmationToken(tokenId: string): ConfirmationToken | undefined` -- retrieves, checks expiry, deletes if expired
   - `deleteConfirmationToken(tokenId: string): void` -- removes token
   - Token ID: use `crypto.randomUUID()` prefixed with `gpt_confirm_`
   - `generateConfirmationToken(clerkUserId, jobId, candidateId, preScreenAnswers?, coverLetter?): ConfirmationToken` -- creates token with 15-minute expiry
  </action>
  <verify>
    Run `cd g:/code/splits.network && npx tsc --noEmit --project services/gpt-service/tsconfig.json` -- should compile without errors for the new files.
  </verify>
  <done>
    types.ts exports all GPT action types. helpers.ts exports error builder, formatters, and confirmation token store. Both compile cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create GptActionRepository and wire into route registration</name>
  <files>
    services/gpt-service/src/v2/actions/repository.ts
    services/gpt-service/src/v2/routes.ts
  </files>
  <action>
Create `services/gpt-service/src/v2/actions/repository.ts`:

A `GptActionRepository` class that wraps Supabase queries. Constructor takes (supabaseUrl: string, supabaseKey: string). Creates its own Supabase client (same pattern as ats-service's JobRepository).

Methods:

1. **searchJobs(keywords?: string, location?: string, commuteType?: string, jobLevel?: string, page: number = 1):**
   - Query `jobs` table with company join: `*, company:companies!inner(id, name, industry, headquarters_location, logo_url)`
   - Always filter: `status = 'active'`, `deleted_at IS NULL`
   - If keywords: use `.textSearch('search_vector', tsquery, { type: 'websearch', config: 'english' })` (same pattern as ats-service JobRepository)
   - If location: use `.ilike('location', '%${location}%')` (only when keywords is NOT provided, to avoid conflict with textSearch - same pattern as ats-service)
   - If commuteType: use `.overlaps('commute_types', [commuteType])` (same pattern as ats-service)
   - If jobLevel: use `.eq('job_level', jobLevel)`
   - Limit: hardcoded 5
   - Order: created_at desc
   - Pagination: range based on page * 5
   - Return `{ data: any[], total: number }` using `{ count: 'exact' }`

2. **getJobDetail(jobId: string):**
   - Query `jobs` with expanded company join: `*, company:companies(id, name, industry, headquarters_location, logo_url, description, website)`
   - Filter: `id = jobId` AND `status = 'active'`
   - Use `.single()`
   - If not found (PGRST116), return null
   - Also fetch job_requirements: query `job_requirements` table where `job_id = jobId`, order by `requirement_type, created_at`
   - Also fetch pre_screen_questions: query `job_pre_screen_questions` table where `job_id = jobId`, order by `created_at`
   - Return combined object: `{ ...job, requirements, pre_screen_questions }`

3. **getApplicationsForCandidate(candidateId: string, includeInactive: boolean = false, page: number = 1):**
   - Query `applications` with job+company join: `*, job:jobs(id, title, company:companies(id, name))`
   - Filter: `candidate_id = candidateId`
   - If not includeInactive: filter to stages `['draft', 'submitted', 'company_review', 'interview', 'offer', 'ai_review', 'screen', 'recruiter_proposed', 'recruiter_request']` (active stages only)
   - Limit: 10, order by created_at desc
   - Return `{ data: any[], total: number }` using `{ count: 'exact' }`

4. **checkDuplicateApplication(candidateId: string, jobId: string):**
   - Query `applications` where `candidate_id = candidateId` AND `job_id = jobId` AND `stage NOT IN ('withdrawn', 'rejected')`
   - Return first match or null (use `.maybeSingle()`)

5. **createApplication(candidateId: string, jobId: string, coverLetter?: string):**
   - Insert into `applications` table: `{ candidate_id: candidateId, job_id: jobId, cover_letter: coverLetter, stage: 'submitted', submitted_at: new Date().toISOString() }`
   - Return created row via `.select().single()`

6. **savePreScreenAnswers(applicationId: string, answers: { question_id: string, answer: string }[]):**
   - For each answer, upsert into `job_pre_screen_answers`: `{ application_id: applicationId, question_id: answer.question_id, answer: answer.answer }` with onConflict: 'application_id,question_id'
   - Return void

7. **getPreScreenQuestions(jobId: string):**
   - Query `job_pre_screen_questions` where `job_id = jobId`, order by created_at
   - Return array

8. **getCandidateResume(candidateId: string):**
   - Query `documents` where `entity_type = 'candidate'` AND `entity_id = candidateId` AND `deleted_at IS NULL`
   - Order by created_at desc, limit 1
   - Return first document or null
   - Resume text is in `metadata.extracted_text` (JSONB field)

9. **resolveCandidateId(clerkUserId: string):**
   - Use `resolveAccessContext` from `@splits-network/shared-access-context` to get candidateId
   - Import: `import { resolveAccessContext } from '@splits-network/shared-access-context';`
   - If no candidateId, return null
   - Return the candidateId string

Update `services/gpt-service/src/v2/routes.ts`:

- Import GptActionRepository
- Instantiate: `const actionRepository = new GptActionRepository(supabaseUrl, supabaseKey);`
- Add a comment: `// GPT Action routes will be registered in Plans 02-04`
- Export the repository instance via config for later route registration (pass it through or make it accessible)
- Update RegisterConfig interface to be ready for action routes registration

The actual route handlers come in Plans 02-04. This plan just creates the repository and wires it into the service initialization.
  </action>
  <verify>
    Run `cd g:/code/splits.network && npx tsc --noEmit --project services/gpt-service/tsconfig.json` -- should compile without errors.
  </verify>
  <done>
    GptActionRepository has all 9 query methods. routes.ts instantiates the repository. TypeScript compiles cleanly. Foundation layer ready for Plans 02-04.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit --project services/gpt-service/tsconfig.json` passes
- types.ts exports: GptJobSearchParams, GptJobSearchResult, GptJobSearchResponse, GptJobDetail, GptApplicationStatus, GptApplicationListParams, GptSubmitApplicationRequest, GptConfirmationSummary, GptResumeAnalysisRequest, GptResumeAnalysisResponse, GptErrorResponse, ConfirmationToken
- helpers.ts exports: gptError, formatJobForGpt, formatStageLabel, storeConfirmationToken, getConfirmationToken, deleteConfirmationToken, generateConfirmationToken
- repository.ts exports: GptActionRepository class with 9 methods
- routes.ts instantiates GptActionRepository
</verification>

<success_criteria>
Foundation layer compiles cleanly and provides all types, queries, and helpers that Plans 02-04 will use for their route handlers.
</success_criteria>

<output>
After completion, create `.planning/phases/13-gpt-api-endpoints/13-01-SUMMARY.md`
</output>
