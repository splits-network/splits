---
phase: 13-gpt-api-endpoints
plan: 02
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - services/gpt-service/src/v2/actions/routes.ts
  - services/gpt-service/src/v2/routes.ts
autonomous: true

must_haves:
  truths:
    - "Job search returns GPT-formatted results filtered by keywords, location, commute type, and job level"
    - "Job details endpoint returns comprehensive job info including requirements, pre-screen questions, and company details"
    - "Application status endpoint returns the authenticated candidate's applications with human-readable status labels and job context"
  artifacts:
    - path: "services/gpt-service/src/v2/actions/routes.ts"
      provides: "Fastify route handlers for GET /api/v2/jobs/search, GET /api/v2/jobs/:id, GET /api/v2/applications"
      min_lines: 100
  key_links:
    - from: "services/gpt-service/src/v2/actions/routes.ts"
      to: "services/gpt-service/src/v2/actions/repository.ts"
      via: "GptActionRepository method calls"
      pattern: "repository\\.searchJobs|repository\\.getJobDetail|repository\\.getApplicationsForCandidate"
    - from: "services/gpt-service/src/v2/actions/routes.ts"
      to: "services/gpt-service/src/v2/oauth/middleware.ts"
      via: "preHandler hooks"
      pattern: "extractGptAuth|requireScope"
    - from: "services/gpt-service/src/v2/routes.ts"
      to: "services/gpt-service/src/v2/actions/routes.ts"
      via: "registerActionRoutes function call"
      pattern: "registerActionRoutes"
---

<objective>
Implement the three read-only GPT API endpoints: job search, job details, and application status. These are the core read actions that ChatGPT uses to browse jobs and check application status for the authenticated candidate.

Purpose: ENDP-01 (job search), ENDP-02 (job details), ENDP-03 (application status), ENDP-07 (candidate-scoped auth). These read endpoints are the most frequently called GPT actions and form the foundation of the conversational job search experience.

Output: routes.ts with 3 GET endpoints, wired into gpt-service route registration
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13-gpt-api-endpoints/13-CONTEXT.md

@services/gpt-service/src/v2/oauth/middleware.ts
@services/gpt-service/src/v2/oauth/types.ts
@services/gpt-service/src/v2/routes.ts

Reference Plan 01 SUMMARY for types, repository, and helpers that are available.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create read-only GPT action route handlers</name>
  <files>
    services/gpt-service/src/v2/actions/routes.ts
  </files>
  <action>
Create `services/gpt-service/src/v2/actions/routes.ts` with a `registerActionRoutes(app, config)` function.

Config interface: `{ repository: GptActionRepository, oauthService: OAuthService }` -- needs OAuthService to create the extractGptAuth middleware.

All routes use preHandler hooks: `[extractGptAuth(oauthService)]` plus `requireScope(scope)` for per-endpoint scope control.

**Route 1: GET /api/v2/jobs/search**
- Scope: `jobs:read`
- Query params: keywords, location, commute_type, job_level, page (all optional)
- Handler:
  1. Parse query params (page defaults to 1)
  2. Call `repository.searchJobs(keywords, location, commuteType, jobLevel, page)`
  3. Map results through `formatJobForGpt()` helper
  4. Return: `{ data: { jobs: GptJobSearchResult[], pagination: { page, total_pages, total_results } } }`
  5. If no results, return 200 with empty jobs array (not 404)
- Error handling: wrap in try/catch, return `gptError('INTERNAL_ERROR', ...)` on failure

**Route 2: GET /api/v2/jobs/:id**
- Scope: `jobs:read`
- Path param: id (UUID)
- Handler:
  1. Validate id is UUID format (regex check: `/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i`)
  2. Call `repository.getJobDetail(id)`
  3. If null, return 404 with `gptError('NOT_FOUND', 'Job not found or no longer active', { suggestion: 'Try searching for similar jobs using the job search endpoint' })`
  4. Format response: map job to GptJobDetail shape
     - Include: all GptJobSearchResult fields
     - Plus: full description, responsibilities
     - Plus: requirements array mapped to { text: req.description, type: req.requirement_type }
     - Plus: pre_screen_questions array mapped to { id: q.id, question: q.question, type: q.question_type, is_required: q.is_required }
     - Plus: company object: { name, industry, location: headquarters_location, website, description }
  5. Return: `{ data: formattedJobDetail }`

**Route 3: GET /api/v2/applications**
- Scope: `applications:read`
- Query params: include_inactive (boolean string), page (optional)
- Handler:
  1. Get clerkUserId from `request.gptAuth!.clerkUserId`
  2. Call `repository.resolveCandidateId(clerkUserId)`
  3. If no candidateId: return 404 with `gptError('NOT_FOUND', 'No candidate profile found for your account', { suggestion: 'Create a candidate profile at applicant.network/portal/profile' })`
  4. Parse include_inactive from query string (default false)
  5. Call `repository.getApplicationsForCandidate(candidateId, includeInactive, page)`
  6. Map each application to GptApplicationStatus:
     - id: app.id
     - job_title: app.job?.title || 'Unknown'
     - company_name: app.job?.company?.name || 'Unknown'
     - status_label: formatStageLabel(app.stage)
     - applied_date: format app.created_at as 'YYYY-MM-DD'
     - last_updated: format app.updated_at as 'YYYY-MM-DD'
  7. Return: `{ data: { applications: mapped[], pagination: { page, total_pages, total_results } } }`
  </action>
  <verify>
    Run `cd g:/code/splits.network && npx tsc --noEmit --project services/gpt-service/tsconfig.json` -- should compile without errors.
  </verify>
  <done>
    Three read-only GPT endpoints are implemented: job search with filtering, job details with requirements and pre-screen questions, application status with human-readable labels. All use extractGptAuth + requireScope middleware.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire action routes into gpt-service route registration</name>
  <files>
    services/gpt-service/src/v2/routes.ts
  </files>
  <action>
Update `services/gpt-service/src/v2/routes.ts`:

1. Import `registerActionRoutes` from `./actions/routes`
2. After the existing `registerOAuthRoutes` and `registerWebhookRoutes` calls, add:
   ```
   registerActionRoutes(app, { repository: actionRepository, oauthService });
   ```
3. The GptActionRepository should already be instantiated from Plan 01. Make sure it's passed to registerActionRoutes.
4. The OAuthService is already instantiated. Pass it to registerActionRoutes for middleware creation.

The api-gateway wildcard routes (`/api/v1/gpt/*`) already handle forwarding to gpt-service's `/api/v2/*` paths, so no api-gateway changes needed. The routes:
- `/api/v1/gpt/jobs/search` -> gpt-service `/api/v2/jobs/search`
- `/api/v1/gpt/jobs/:id` -> gpt-service `/api/v2/jobs/:id`
- `/api/v1/gpt/applications` -> gpt-service `/api/v2/applications`
  </action>
  <verify>
    Run `cd g:/code/splits.network && npx tsc --noEmit --project services/gpt-service/tsconfig.json` -- should compile without errors. Routes are registered without startup errors.
  </verify>
  <done>
    gpt-service registers all 3 read-only action routes on startup. Route paths are accessible via api-gateway wildcard proxy.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit --project services/gpt-service/tsconfig.json` passes
- routes.ts exports registerActionRoutes function
- Three routes registered: GET /api/v2/jobs/search, GET /api/v2/jobs/:id, GET /api/v2/applications
- All routes use extractGptAuth + requireScope preHandler middleware
- Job search uses jobs:read scope, applications uses applications:read scope
- Error responses follow { error: { code, message, suggestion } } format
</verification>

<success_criteria>
All three read-only GPT endpoints compile and are registered. Job search filters by keywords/location/commute_type/job_level with 5 results per page. Job details include requirements and pre-screen questions. Application status shows human-readable labels for the authenticated candidate only.
</success_criteria>

<output>
After completion, create `.planning/phases/13-gpt-api-endpoints/13-02-SUMMARY.md`
</output>
